<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="css/head.css">
		<title>碎片抽奖模拟器</title>
		<style>
			:root {
				--primary-color: #e74c3c;
				--secondary-color: #3498db;
				--epic-color: #9b59b6;
				--rare-color: #2ecc71;
				--common-color: #95a5a6;
				--bg-color: #ffffff;
				--card-bg: #34495e;
				--text-color: #333333;
			}

			.control-panel,
			.results-panel,
			.epic-table,
			.result-table,
			.log-container,
			.modal-content {
				background: #f5f5f5 !important;
			}

			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: 'Microsoft YaHei', sans-serif;
				background: var(--bg-color);
				color: var(--text-color);
				line-height: 1.6;
				padding: 20px;
				min-height: 100vh;
			}

			.container {
				max-width: 1400px;
				margin: 0 auto;
			}

			h1 {
				color: var(--primary-color);
				margin-bottom: 10px;
				font-size: 2.5rem;
				text-align: center;
			}

			.main-content {
				display: grid;
				grid-template-columns: 1fr;
				gap: 20px;
				margin-bottom: 30px;
			}

			.control-panel {
				background: var(--card-bg);
				padding: 20px;
				border-radius: 10px;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
			}

			.epic-rewards {
				margin-bottom: 20px;
			}

			.epic-table {
				width: 100%;
				border-collapse: collapse;
				margin: 10px 0;
			}

			.epic-table th,
			.epic-table td {
				border: 1px solid #555;
				padding: 8px;
				text-align: center;
			}

			.epic-table th {
				background: var(--epic-color);
			}

			.progress-container {
				margin: 20px 0;
				text-align: center;
			}

			.progress-bar {
				width: 100%;
				height: 30px;
				background: #555;
				border-radius: 15px;
				overflow: hidden;
				margin: 10px 0;
			}

			.progress-fill {
				height: 100%;
				background: linear-gradient(90deg, var(--secondary-color), var(--primary-color));
				width: 0%;
				transition: width 0.3s ease;
			}

			.draw-buttons {
				display: flex;
				gap: 10px;
				margin: 20px 0;
			}

			.btn {
				padding: 12px 20px;
				border: none;
				border-radius: 5px;
				cursor: pointer;
				font-size: 1rem;
				font-weight: bold;
				transition: all 0.3s ease;
				flex: 1;
			}

			.btn-primary {
				background: var(--primary-color);
				color: white;
			}

			.btn-secondary {
				background: var(--secondary-color);
				color: white;
			}

			.btn-reset {
				background: #e67e22;
				color: white;
			}

			.btn:hover {
				opacity: 0.9;
				transform: translateY(-2px);
			}

			.mode-selector {
				margin: 20px 0;
			}

			.mode-buttons {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 10px;
			}

			.mode-btn {
				padding: 10px;
				background: #555;
				color: white;
				border: none;
				border-radius: 5px;
				cursor: pointer;
			}

			.mode-btn.active {
				background: var(--secondary-color);
			}

			.results-panel {
				background: var(--card-bg);
				padding: 20px;
				border-radius: 10px;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
			}

			.results-grid {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 20px;
			}

			.result-table {
				width: 100%;
				border-collapse: collapse;
				margin: 10px 0;
			}

			.result-table th,
			.result-table td {
				border: 1px solid #555;
				padding: 8px;
				text-align: center;
			}

			.result-table th {
				background: #555;
			}

			.log-container {
				margin-top: 20px;
				max-height: 300px;
				overflow-y: auto;
				background: #2c3e50;
				padding: 10px;
				border-radius: 5px;
			}

			.log-entry {
				padding: 5px;
				border-bottom: 1px solid #555;
				font-size: 0.9rem;
			}

			.log-entry:first-child {
				background-color: rgba(255, 255, 255, 0.1);
			}

			/* 碎片格子样式 */
			.fragments-grid {
				display: flex;
				flex-wrap: wrap;
				gap: 5px;
				margin: 20px 0;
				justify-content: center;
			}

			.fragment-cell {
				width: 30px;
				height: 30px;
				border: 2px solid #ccc;
				border-radius: 4px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 0.8rem;
				font-weight: bold;
				transition: all 0.3s ease;
			}

			.fragment-cell.owned {
				background-color: var(--primary-color);
				color: white;
				border-color: var(--primary-color);
			}

			/* 免责声明样式 */
			.disclaimer {
				margin: 0 auto 20px;
				padding: 15px 20px;
				background: #d60000;
				border-left: 8px solid #ffd700;
				border-radius: 6px;
				box-shadow: 0 0 12px rgba(255, 0, 0, .6);
				font-size: 1.15rem;
				font-weight: bold;
				color: #ffd700;
				text-align: center;
				letter-spacing: 1px;
				line-height: 1.6;
			}

			/* 弹窗样式 */
			.modal {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.7);
				z-index: 1000;
				justify-content: center;
				align-items: center;
			}

			.modal-content {
				background: var(--card-bg);
				padding: 30px;
				border-radius: 10px;
				text-align: center;
				max-width: 400px;
				width: 90%;
			}

			.modal-buttons {
				display: flex;
				gap: 10px;
				margin-top: 20px;
				justify-content: center;
			}

			/* 让弹窗里的文字居中 */
			#epic-popup .modal-content {
				max-width: 380px;
			}

			#epic-title {
				color: var(--epic-color);
				margin-bottom: 10px;
			}

			.stats-display {
				margin: 15px 0;
				padding: 10px;
				background: #2c3e50;
				border-radius: 5px;
				color: #ecf0f1;
			}

			.stats-display div {
				margin: 5px 0;
			}

			.formula-section {
				margin: 20px 0;
				padding: 0;
				background: #1e1e1e;
				border-radius: 10px;
				overflow: hidden;
				color: #dcdcdc;
				font-size: 13px;
				line-height: 1.5;
				text-align: left;
			}

			.formula-block {
				position: relative;
				padding: 12px 15px;
				margin: 0;
				background: #282c34;
				border-left: 4px solid;
				text-align: left;
			}

			.formula-block:nth-child(1) {
				border-left-color: #ff79c6;
			}

			.formula-block:nth-child(2) {
				border-left-color: #8be9fd;
			}

			.formula-block:nth-child(3) {
				border-left-color: #50fa7b;
			}

			.formula-block h4 {
				margin: 0 0 8px 0;
				font-size: 14px;
				color: #ffb86c;
				font-weight: bold;
				text-align: left;
			}

			.prob-table {
				width: 100%;
				border-collapse: collapse;
				margin: 8px 0;
				font-size: 12px;
				text-align: left;
			}

			.prob-table td {
				padding: 4px 6px;
				border: 1px solid #444;
				text-align: center;
				text-align: left;
			}

			.prob-table .prob-value {
				color: #50fa7b;
				font-weight: bold;
				text-align: left;
			}

			.prob-table .prob-label {
				color: #aaa;
				text-align: left;
			}

			.formula-code {
				background: #1e1e1e;
				padding: 8px 10px;
				border-radius: 6px;
				font-family: "Consolas", "Courier New", monospace;
				white-space: pre;
				overflow-x: auto;
				font-size: 12px;
				line-height: 1.4;
				margin: 8px 0;
				border: 1px solid #333;
				text-align: left;
			}

			.formula-code .line {
				display: inline-block;
				width: 25px;
				color: #6272a4;
				user-select: none;
				text-align: left;
			}


			/* 响应式设计 */
			@media (max-width: 780px) {
				.main-content {
					grid-template-columns: 1fr;
				}

				.results-grid {
					grid-template-columns: 1fr;
				}

				h1 {
					font-size: 2rem;
				}

				.control-panel,
				.results-panel {
					padding: 15px;
				}

				.draw-buttons {
					gap: 8px;
					margin: 15px 0;
				}

				.btn {
					padding: 10px 15px;
					font-size: 0.9rem;
				}

				.formula-section {
					font-size: 12px;
					text-align: left;
				}

				.formula-block {
					text-align: left;
				}

				.formula-code {
					font-size: 11px;
					text-align: left;
				}

				.prob-table {
					font-size: 11px;
					text-align: left;
				}
			}

			@media (max-width: 480px) {
				.main-content {
					grid-template-columns: 1fr;
					gap: 15px;
				}

				.draw-buttons {
					flex-direction: column;
				}

				.mode-buttons {
					grid-template-columns: 1fr;
				}

				body {
					padding: 10px;
				}

				h1 {
					font-size: 1.8rem;
				}

				.control-panel,
				.results-panel {
					padding: 12px;
				}

				.formula-section {
					font-size: 11px;
					text-align: left;
				}

				.formula-block {
					padding: 10px 12px;
					text-align: left;
				}

				.formula-code {
					font-size: 10px;
					padding: 6px 8px;
					text-align: left;
				}

				.prob-table {
					font-size: 10px;
					text-align: left;
				}

				.fragment-cell {
					width: 25px;
					height: 25px;
					font-size: 0.7rem;
				}
			}

			.code-explanation {
				margin: 40px auto;
				max-width: 1200px;
				background: #2c3e50;
				border-radius: 10px;
				overflow: hidden;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
			}

			.explanation-header {
				background: #34495e;
				padding: 15px 20px;
				cursor: pointer;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.explanation-header h3 {
				color: #ecf0f1;
				margin: 0;
				font-size: 1.3rem;
			}

			.toggle-icon {
				color: #ecf0f1;
				font-size: 1.5rem;
				transition: transform 0.3s ease;
			}

			.explanation-content {
				padding: 0;
				max-height: 0;
				overflow: hidden;
				transition: max-height 0.5s ease, padding 0.3s ease;
			}

			.explanation-content.expanded {
				padding: 20px;
				max-height: none;
				overflow: visible;
			}

			.code-section {
				margin-bottom: 25px;
				background: #1e272e;
				border-radius: 8px;
				overflow: hidden;
			}

			.code-title {
				background: #34495e;
				padding: 10px 15px;
				color: #ecf0f1;
				font-weight: bold;
				border-left: 4px solid #3498db;
			}

			.code-desc {
				padding: 15px;
				color: #bdc3c7;
				line-height: 1.6;
				font-size: 0.95rem;
			}

			.code-block {
				background: #1a1a1a;
				border-left: 4px solid #e74c3c;
				padding: 15px;
				margin: 10px 0;
				overflow-x: auto;
				font-family: 'Consolas', 'Courier New', monospace;
				font-size: 0.9rem;
				line-height: 1.4;
				color: #f8f9fa;
				overflow: auto;
			}

			.code-line {
				margin: 5px 0;
			}

			.code-comment {
				color: #6c757d;
				font-style: italic;
			}

			.code-keyword {
				color: #e74c3c;
			}

			.code-function {
				color: #3498db;
			}

			.code-number {
				color: #2ecc71;
			}

			.code-string {
				color: #f39c12;
			}

			@media (max-width: 768px) {
				.code-explanation {
					margin: 20px 10px;
				}

				.explanation-header {
					padding: 12px 15px;
				}

				.explanation-header h3 {
					font-size: 1.1rem;
				}

				.explanation-content.expanded {
					padding: 15px;
				}

				.code-block {
					padding: 10px;
					font-size: 0.85rem;
				}
			}

			#bulk-result-table {
				font-size: 0.85rem;
			}

			#bulk-close-result {
				width: 24px;
				height: 24px;
				padding: 0;
				line-height: 24px;
				text-align: center;
				font-size: 14px;
			}

			#bulk-export-txt.disabled {
				background: #6c757d;
				cursor: not-allowed;
			}
			
			@media (max-width: 480px) {
			  body { font-size: 14px; }
			
			  .prob-table {
			    display: block;
			    width: 100%;
			    overflow-x: auto;
			    white-space: nowrap;
			  }
			  .prob-table td { padding: 2px 4px; font-size: 11px; }
			
			  #bulk-result-modal .modal-content {
			    max-width: 95vw !important;
			    max-height: 85vh !important;
			  }
			  #bulk-result-table { font-size: 0.75rem; }
			
			  .draw-buttons,
			  .modal-buttons {
			    flex-direction: column;
			  }
			  .btn { width: 100%; margin-bottom: 6px; }
			
			  .drag-handle {
			    padding: 6px 8px;
			    font-size: 0.9rem;
			  }
			  #bulk-close-result {
			    width: 22px;
			    height: 22px;
			    line-height: 22px;
			    font-size: 13px;
			  }
			}

		</style>
	</head>
	<body>
		<section class="hero-section">
			<h1 class="hero-title">梦之回廊模拟器</h1>
			<div class="nav-buttons">
				<button class="nav-button"><a href="index.html">返回新版主页</a></button>
				<button class="nav-button"><a href="indexjd.html">返回经典版主页</a></button>
			</div>
			<h3 class="hero-title">请尽量使用Windows系统以获得最优的体验效果</h3>
			<h3 class="hero-title">该页面可以脱离head.css独立运行</h3>
			<h3 class="hero-title">为了规避一些风险，本页面为github独占</h3>
		</section>
		<div class="container">
			<!-- 免责声明 -->
			<div class="disclaimer">
				⚠️ 免责声明 ⚠️<br>
				本页面仅供学习交流与技术演示使用，所有概率、数据及抽奖结果均为模拟生成，
				与《三国杀》官方实际活动、爆率或结果无关，请勿据此进行任何投资或消费决策！
			</div>

			<!-- 碎片进度展示 -->
			<div class="progress-container">
				<h3>碎片收集进度(本页面展示的是250抽软保底的常规单形态回廊皮)</h3>
				<div class="fragments-grid" id="fragments-grid">
					<!-- 25个碎片格子将通过JS动态生成 -->
				</div>
			</div>

			<div class="main-content">
				<!-- 左侧控制面板 -->
				<div class="control-panel">
					<div class="stats-display">
						<div>你已抽取了：<span id="draw-count">0</span> 次</div>
						<div>你已花费了：<span id="cost">0</span> 元（每抽=3元）</div>
						<div>当前拥有碎片：<span id="owned-count">0</span>/25</div>
						<div>未来10抽获得终极碎片的概率：<span id="future-10-prob">0%</span></div>
					</div>

					<div class="draw-buttons">
						<button class="btn btn-primary" id="draw-1">抽1次</button>
						<button class="btn btn-primary" id="draw-10">抽10次</button>
						<button class="btn btn-primary" id="draw-30">抽30次</button>
					</div>

					<button class="btn btn-reset" id="reset-btn">重置抽奖</button>
					<button class="btn btn-secondary" id="bulk-test-btn">百万次测试</button>

					<div class="results-panel">
						<h3>抽取日志</h3>
						<div class="log-container" id="log-container">
							<!-- 日志将通过JS动态添加 -->
						</div>
					</div>

					<!-- 公式展示区域 -->
					<div class="formula-section">
						<!-- 概率表 -->
						<div class="formula-block">
							<h4>单抽获得新碎片概率（随已有片数递减）</h4>
							<p>该部分取自官方概率公示</p>
							<div id="prob-bars"></div>
						</div>

						<!-- 累积概率公式 -->
						<div class="formula-block">
							<h4>累积保底函数 F(n)</h4>
							<p>该部分为300抽硬保底的推理公式，非官方概率</p>
							<div class="formula-code">
<span class="line">1</span>// 第 n 抽首次拿到第 25 片的累积概率<br>
<span class="line">2</span>if 25≤n≤199: &nbsp;&nbsp;F(n) = 0.00005×(n−24)<br>
<span class="line">3</span>if 200≤n≤250: F(n) = 0.00875 +0.97625×[1−e^(−0.09×(n−199))]<br>
<span class="line">4</span>if 251≤n≤300: F(n) = 0.985 + 0.015×[1−e^(−0.46×(n−250))]<br>
<span class="line">5</span>if n≥301: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F(n) = 1
							</div>
						</div>

						<div class="formula-block">
							<h4>一句话总结</h4>
							<p>前 22 片按固定概率掉落；第 23~25 片进入「soft-pity」：240 抽后概率从 5% 开始线性飙升，271 抽起必出，300 抽硬保底必齐！</p>
						</div>
					</div>
				</div>
			</div>
		</div>

		<div class="modal" id="bulk-result-modal">
			<div class="modal-content draggable"
				style="max-width:620px; max-height:90vh; display:flex; flex-direction:column;">
				<div class="drag-handle"
					style="cursor:move; background:#34495e; color:#fff; padding:8px 12px; display:flex; justify-content:space-between; align-items:center;">
					<span>百万次25号碎片测试结果</span>
					<button class="btn btn-primary" id="bulk-close-result"
						style="padding:4px 10px; font-size:0.9rem;">✖</button>
				</div>

				<div style="overflow:auto; flex:1; padding:10px;">
					<table class="result-table" id="bulk-result-table"></table>
				</div>

				<div class="modal-buttons" style="flex-shrink:0; padding:10px; border-top:1px solid #555;">
					<button class="btn btn-secondary" id="bulk-retest-btn">重新测试</button>
					<button class="btn btn-secondary" id="bulk-export-txt">导出txt表格</button>
				</div>
			</div>
		</div>

		<div class="modal" id="bulk-confirm-modal">
			<div class="modal-content">
				<h3>⚠️ 警告</h3>
				<p>即将执行<strong>一百万次</strong>25号碎片抽取测试，浏览器可能会卡顿数秒，是否继续？</p>
				<div class="modal-buttons">
					<button class="btn btn-primary" id="bulk-confirm-yes">开始</button>
					<button class="btn btn-secondary" id="bulk-confirm-no">取消</button>
				</div>
			</div>
		</div>

		<div class="modal" id="bulk-export-confirm">
			<div class="modal-content" style="max-width:380px">
				<h3>导出确认</h3>
				<p>仅支持 Windows 系统！<br>将把下方统计表格导出为 <strong>梦之回廊_百万测试.txt</strong> 并保存到「下载」文件夹。<br>是否继续？</p>
				<div class="modal-buttons">
					<button class="btn btn-primary" id="bulk-export-yes">确认导出</button>
					<button class="btn btn-secondary" id="bulk-export-no">取消</button>
				</div>
			</div>
		</div>

		<div class="code-explanation">
			<div class="explanation-header" id="toggle-explanation">
				<h3>梦之回廊模拟器代码说明</h3>
				<span class="toggle-icon">▼</span>
			</div>
			<div class="explanation-content" id="explanation-content">
				<div class="code-section">
					<div class="code-title">概率配置表 (fragmentProbabilities)</div>
					<div class="code-desc">
						该对象定义了碎片抽奖系统的核心概率规则。键表示当前已拥有的碎片数量，值表示获得下一片新碎片的概率（百分比）。
						这是基于官方公示数据构建的逐片递减概率模型。
					</div>
					<div class="code-block">
						<div class="code-line"><span class="code-keyword">const</span> <span
								class="code-function">fragmentProbabilities</span> = {</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-number">1</span>: <span
								class="code-number">100</span>, <span class="code-comment">// 拥有0片时，抽第1片概率100%</span>
						</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-number">2</span>: <span
								class="code-number">96</span>, <span class="code-comment">// 拥有1片时，抽第2片概率96%</span>
						</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-number">3</span>: <span
								class="code-number">92</span>, <span class="code-comment">// 拥有2片时，抽第3片概率92%</span>
						</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-comment">// ... 中间部分省略</span></div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-number">25</span>: <span
								class="code-number">0.29</span> <span class="code-comment">// 拥有24片时，抽第25片概率0.29%</span>
						</div>
						<div class="code-line">};</div>
					</div>
				</div>

				<div class="code-section">
					<div class="code-title">累积概率函数 (cumulativeProbability)</div>
					<div class="code-desc">
						该函数计算在第n抽时已经获得第25片碎片的累积概率。采用分段函数设计，模拟真实抽奖系统的渐进式保底机制：
						<ul>
							<li>阶段1 (25-199抽)：线性缓慢增长，模拟早期低概率</li>
							<li>阶段2 (200-250抽)：指数增长，进入软保底区间</li>
							<li>阶段3 (251-300抽)：强保底阶段，快速收敛到100%</li>
							<li>硬保底 (301抽及以上)：必定获得全部碎片</li>
						</ul>
					</div>
					<div class="code-block">
						<div class="code-line"><span class="code-keyword">function</span> <span
								class="code-function">cumulativeProbability</span>(n) {</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">if</span> (n &lt; <span
								class="code-number">25</span>) <span class="code-keyword">return</span> <span
								class="code-number">0</span>;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">if</span> (n &lt;= <span
								class="code-number">199</span>) {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">// 阶段1：线性缓慢增长</span>
						</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">return</span> <span
								class="code-number">0.00005</span> * (n - <span class="code-number">24</span>);</div>
						<div class="code-line">&nbsp;&nbsp;} <span class="code-keyword">else</span> <span
								class="code-keyword">if</span> (n &lt;= <span class="code-number">250</span>) {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">//
								阶段2：指数增长，通过反解系数确保F(250)=0.985</span></div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">const</span> k =
							-Math.log(<span class="code-number">1</span> - (<span class="code-number">0.985</span> -
							<span class="code-number">0.00875</span>) / <span class="code-number">0.97625</span>) /
							<span class="code-number">51</span>;</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">return</span> <span
								class="code-number">0.00875</span> + <span class="code-number">0.97625</span> * (<span
								class="code-number">1</span> - Math.exp(-k * (n - <span
								class="code-number">199</span>)));</div>
						<div class="code-line">&nbsp;&nbsp;} <span class="code-keyword">else</span> <span
								class="code-keyword">if</span> (n &lt;= <span class="code-number">300</span>) {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">//
								阶段3：强保底，剩余1.5%概率用陡峭指数快速收敛</span></div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">const</span> λ =
							-Math.log(<span class="code-number">1</span> - (<span class="code-number">1</span> - <span
								class="code-number">0.985</span>) / <span class="code-number">0.015</span>) / <span
								class="code-number">50</span>;</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">return</span> <span
								class="code-number">0.985</span> + <span class="code-number">0.015</span> * (<span
								class="code-number">1</span> - Math.exp(-λ * (n - <span
								class="code-number">250</span>)));</div>
						<div class="code-line">&nbsp;&nbsp;}</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">return</span> <span
								class="code-number">1</span>; <span class="code-comment">// 硬保底</span></div>
						<div class="code-line">}</div>
					</div>
				</div>

				<div class="code-section">
					<div class="code-title">单次抽奖核心函数 (performSingleDraw)</div>
					<div class="code-desc">
						这是抽奖系统的核心执行函数，整合了基础概率、保底机制和特殊规则。函数执行流程：
						<ol>
							<li>更新抽奖计数器</li>
							<li>检查是否已集齐所有碎片</li>
							<li>确定目标碎片编号（顺序获得机制）</li>
							<li>根据目标碎片应用不同的概率规则</li>
							<li>执行概率判定并更新状态</li>
							<li>处理特殊事件（如获得终极碎片）</li>
						</ol>
					</div>
					<div class="code-block">
						<div class="code-line"><span class="code-keyword">function</span> <span
								class="code-function">performSingleDraw</span>() {</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-comment">// 更新抽奖计数器</span></div>
						<div class="code-line">&nbsp;&nbsp;state.drawCount++;</div>
						<div class="code-line">&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-comment">// 检查是否已集齐所有碎片</span></div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">if</span>
							(state.ownedFragments.length &gt;= <span class="code-number">25</span>) {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;addLog(<span
								class="code-string">`第${state.drawCount}抽：已集齐所有碎片，无需再抽`</span>);</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">return</span>;</div>
						<div class="code-line">&nbsp;&nbsp;}</div>
						<div class="code-line">&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-comment">// 确定目标碎片编号（顺序获得机制）</span></div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">const</span> target =
							nextMissing();</div>
						<div class="code-line">&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-comment">// 分阶段概率计算</span></div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">let</span> baseProbability;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">if</span> (target &gt;= <span
								class="code-number">23</span>) {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">// 最后三片：应用Soft
								Pity机制</span></div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;baseProbability = lateFragmentP(state.drawCount);
						</div>
						<div class="code-line">&nbsp;&nbsp;} <span class="code-keyword">else</span> {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">// 前22片：使用官方概率表</span>
						</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;baseProbability = fragmentProbabilities[target] /
							<span class="code-number">100</span>;</div>
						<div class="code-line">&nbsp;&nbsp;}</div>
						<div class="code-line">&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-comment">// 300抽硬保底兜底机制</span></div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">if</span> (state.drawCount &gt;=
							<span class="code-number">300</span> && state.ownedFragments.length &lt; <span
								class="code-number">25</span>) {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;baseProbability = <span
								class="code-number">1</span>;</div>
						<div class="code-line">&nbsp;&nbsp;}</div>
						<div class="code-line">&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-comment">// 概率判定</span></div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">const</span> got = Math.random()
							&lt; baseProbability;</div>
						<div class="code-line">&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-keyword">if</span> (got) {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">// 成功获得新碎片</span>
						</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;state.ownedFragments.push(target);</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">if</span> (target ===
							<span class="code-number">25</span>) {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">//
								获得终极碎片的特殊处理</span></div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addLog(<span
								class="code-string">`第${state.drawCount}抽：获得终极碎片 #25！`</span>);</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateFragmentsGrid();</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateStats();</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">//
								显示恭喜弹窗</span></div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() =&gt; {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;epicPopup.style.display =
							<span class="code-string">'flex'</span>;</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, <span
								class="code-number">500</span>);</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span
								class="code-keyword">return</span>;</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;}</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;addLog(<span
								class="code-string">`第${state.drawCount}抽：获得碎片 #${target}`</span>);</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;updateFragmentsGrid();</div>
						<div class="code-line">&nbsp;&nbsp;} <span class="code-keyword">else</span> {</div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">// 未获得新碎片</span></div>
						<div class="code-line">&nbsp;&nbsp;&nbsp;&nbsp;addLog(<span
								class="code-string">`第${state.drawCount}抽：未获得新碎片`</span>);</div>
						<div class="code-line">&nbsp;&nbsp;}</div>
						<div class="code-line">&nbsp;&nbsp;</div>
						<div class="code-line">&nbsp;&nbsp;<span class="code-comment">// 更新界面显示</span></div>
						<div class="code-line">&nbsp;&nbsp;updateStats();</div>
						<div class="code-line">}</div>
					</div>
				</div>

				<div class="code-section">
					<div class="code-title">系统设计特点</div>
					<div class="code-desc">
						<strong>概率系统</strong>：结合官方概率数据和渐进式保底机制，模拟真实抽奖体验。<br>
						<strong>抽奖逻辑</strong>：采用顺序获得机制确保碎片按编号顺序获得，无跳号现象。<br>
						<strong>保底机制</strong>：包含Soft Pity机制（后期概率线性提升）和硬保底兜底（300抽强制获得）。<br>
						<strong>特殊处理</strong>：25号碎片检测和批量抽奖优化（集齐后自动停止）。<br><br>

						这套系统通过数学建模和概率计算，准确地模拟了真实抽奖系统的行为，为学习交流提供了可靠的技术演示。
					</div>
				</div>
			</div>
		</div>


		<!-- 恭喜弹窗 -->
		<div class="modal" id="epic-popup">
			<div class="modal-content">
				<h2 id="epic-title">恭喜！</h2>
				<p>您已成功收集全部25个碎片，获得终极奖励！</p>
				<div class="modal-buttons">
					<button class="btn btn-primary" id="close-popup">确定</button>
				</div>
			</div>
		</div>

		<footer class="site-footer">
			<div class="author-info">
				<p>
					作者： <a href="https://space.bilibili.com/87412647?spm_id_from=333.1007.0.0"
						target="_blank">bilibili月が綺麗ですね_</a><br />
					联系方式：<a href="mailto:3099637681@qq.com" target="_blank">3099637681@qq.com（QQ同号）</a><br />
					有什么新功能或建议欢迎骚扰（著名来意）<br />
					<a href="https://1145141919810tonny.github.io/sgsmoniqi/" target="_blank">点击此处使用GitHub Pages在线服务</a>
				</p>
			</div>
			<div class="code-update">
				<a href="https://www.bilibili.com/read/readlist/rl929858?spm_id_from=333.1387.0.0" target="_blank"
					class="bili-btn" rel="noopener noreferrer">
					[bilibili]获取更新动态
				</a>
				<a href="https://github.com/1145141919810TONNY/sgsmoniqi/" target="_blank" class="github-btn"
					rel="noopener noreferrer">
					[GitHub]获取后续代码更新
				</a>
				<a href="https://gitcode.com/TONNY114514/sgsmnq?source_module=search_project" target="_blank"
					class="gitcode-btn" rel="noopener noreferrer">
					[GitCode]获取V7.8.3.62镜像文件
				</a>
			</div>
			<div class="license-notice">
			  <p>
			    Copyright &copy;<span id="copyright-year">2025-<span id="current-year"></span></span> bilibili月が綺麗ですね_<br />
			    本页部分文件受
			    <a href="LICENSE-NC.html"
			       title="查看 Educational/Non-Commercial 许可证" class="license-link" target="_blank">
			      EE-NC 许可证
				  <!--SPDX-License-Identifier: LicenseRef-EE-NC-->
				  <!--SPDX-FileCopyrightText: 2025-2026 bilibili月が綺麗ですね_-->
			    </a> 约束，禁止商用；<br />
			    其余文件继续适用
			    <a href="MIT LICENSE.html"
			       title="查看 MIT 许可证" class="license-link" target="_blank">
			      MIT License
			    </a>
			  </p>
			  <p class="i18n-annotation">
			    (法律条款以对应英文版（MIT 许可证）或中文版（EE-NC 许可证）文件为准，与本页摘要不一致时，以前述完整文本为准)
			  </p>
			</div>
		<script>
		document.getElementById('current-year').textContent = new Date().getFullYear();
	</script>
		</footer>

		<script>
			// SPDX-License-Identifier: LicenseRef-EE-NC
			// SPDX-FileCopyrightText: 2025-2026 bilibili月が綺麗ですね_


			// 概率数据
			const fragmentProbabilities = {
				1: 100,
				2: 96,
				3: 92,
				4: 88,
				5: 84,
				6: 80,
				7: 76,
				8: 72,
				9: 68,
				10: 64,
				11: 42.86,
				12: 40,
				13: 37.14,
				14: 34.29,
				15: 31.43,
				16: 25,
				17: 22.5,
				18: 20,
				19: 17.5,
				20: 15,
				21: 2.44,
				22: 1.95,
				23: 1.46,
				24: 0.98,
				25: 0.29
			};

			// 累积概率函数 F(n)
			function cumulativeProbability(n) {
				if (n < 25) return 0;
				if (n <= 199) {
					return 0.00005 * (n - 24); // 25-199 缓慢爬坡
				} else if (n <= 250) {
					// 反解 k 使 F(250)=0.985
					const k = -Math.log(1 - (0.985 - 0.00875) / 0.97625) / 51; // ≈0.07331
					return 0.00875 + 0.97625 * (1 - Math.exp(-k * (n - 199)));
				} else if (n <= 300) {
					// 剩余 1.5% 用更陡指数补完
					const λ = -Math.log(1 - (1 - 0.985) / 0.015) / 50; // ≈0.4605
					return 0.985 + 0.015 * (1 - Math.exp(-λ * (n - 250)));
				}
				return 1; // 硬保底
			}

			// 单次概率 p(n) = F(n) - F(n-1)
			function singleProbability(n) {
				if (n < 25) return 0;
				if (n === 25) return cumulativeProbability(25);
				return cumulativeProbability(n) - cumulativeProbability(n - 1);
			}

			// 应用状态
			let state = {
				drawCount: 0,
				ownedFragments: [], // 已拥有的碎片编号
				logs: [] // 抽取日志
			};

			// DOM元素
			const fragmentsGrid = document.getElementById('fragments-grid');
			const drawCountEl = document.getElementById('draw-count');
			const costEl = document.getElementById('cost');
			const ownedCountEl = document.getElementById('owned-count');
			const logContainer = document.getElementById('log-container');
			const epicPopup = document.getElementById('epic-popup');
			const closePopupBtn = document.getElementById('close-popup');

			// 初始化碎片格子
			function initFragmentsGrid() {
				fragmentsGrid.innerHTML = '';
				for (let i = 1; i <= 25; i++) {
					const cell = document.createElement('div');
					cell.className = 'fragment-cell';
					cell.textContent = i;
					cell.id = `fragment-${i}`;
					fragmentsGrid.appendChild(cell);
				}
			}

			// 更新碎片格子显示
			function updateFragmentsGrid() {
				for (let i = 1; i <= 25; i++) {
					const cell = document.getElementById(`fragment-${i}`);
					if (state.ownedFragments.includes(i)) {
						cell.classList.add('owned');
					} else {
						cell.classList.remove('owned');
					}
				}
			}

			function calculateFuture10Probability() {
				const currentDraws = state.drawCount;
				const ownedCount = state.ownedFragments.length;

				if (state.ownedFragments.includes(25)) {
					return 0;
				}

				if (ownedCount < 24) {
					let probability = 0;

					for (let i = 1; i <= 10; i++) {
						const drawNumber = currentDraws + i;

						const nextFragment = ownedCount + 1;
						let fragmentProb;

						if (nextFragment >= 23) {
							fragmentProb = lateFragmentP(drawNumber);
						} else {
							fragmentProb = fragmentProbabilities[nextFragment] / 100;
						}

						probability = 1 - (1 - probability) * (1 - fragmentProb);

						if (nextFragment >= 24) {
							let ultimateProb = 0;
							for (let j = i + 1; j <= 10; j++) {
								const ultimateDrawNumber = currentDraws + j;
								let ultimateFragmentProb;

								if (ultimateDrawNumber >= 300) {
									ultimateFragmentProb = 1;
								} else {
									ultimateFragmentProb = lateFragmentP(ultimateDrawNumber);
								}

								ultimateProb = 1 - (1 - ultimateProb) * (1 - ultimateFragmentProb);
							}

							return probability * ultimateProb;
						}
					}

					return 0;
				} else if (ownedCount === 24) {
					let probability = 0;

					for (let i = 1; i <= 10; i++) {
						const drawNumber = currentDraws + i;
						let singleDrawProb;

						if (drawNumber >= 300) {
							singleDrawProb = 1;
						} else {
							singleDrawProb = lateFragmentP(drawNumber);
						}

						probability = 1 - (1 - probability) * (1 - singleDrawProb);
					}

					return probability;
				}

				return 0;
			}

			function calculateFuture10ProbabilityAdvanced() {
				const currentDraws = state.drawCount;
				const ownedCount = state.ownedFragments.length;

				if (state.ownedFragments.includes(25)) {
					return 0;
				}

				let totalProbability = 0;

				function calculatePathProbability(drawsRemaining, currentFragment, probabilitySoFar) {
					if (drawsRemaining === 0) {
						return currentFragment >= 25 ? probabilitySoFar : 0;
					}

					if (currentFragment >= 25) {
						return probabilitySoFar;
					}

					let pathProb = 0;
					const nextDrawNumber = currentDraws + (10 - drawsRemaining) + 1;

					let successProb;
					if (currentFragment >= 23) {
						successProb = lateFragmentP(nextDrawNumber);
					} else {
						successProb = fragmentProbabilities[currentFragment + 1] / 100;
					}

					if (nextDrawNumber >= 300) {
						successProb = 1;
					}

					pathProb += calculatePathProbability(
						drawsRemaining - 1,
						currentFragment + 1,
						probabilitySoFar * successProb
					);

					pathProb += calculatePathProbability(
						drawsRemaining - 1,
						currentFragment,
						probabilitySoFar * (1 - successProb)
					);

					return pathProb;
				}

				totalProbability = calculatePathProbability(10, ownedCount, 1);
				return totalProbability;
			}


			// 更新统计信息
			function updateStats() {
				drawCountEl.textContent = state.drawCount;
				costEl.textContent = state.drawCount * 3;
				ownedCountEl.textContent = state.ownedFragments.length;

				const futureProb = calculateFuture10ProbabilityAdvanced();
				const futureProbEl = document.getElementById('future-10-prob');
				if (futureProbEl) {
					if (futureProb === 0) {
						futureProbEl.textContent = '0%';
					} else if (futureProb < 0.0001) {
						futureProbEl.textContent = '< 0.01%';
					} else {
						futureProbEl.textContent = (futureProb * 100).toFixed(2) + '%';
					}
				}
			}

			// 添加日志
			function addLog(message) {
				const timestamp = new Date().toLocaleTimeString();
				const logEntry = document.createElement('div');
				logEntry.className = 'log-entry';
				logEntry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;

				// 最新日志置顶
				logContainer.insertBefore(logEntry, logContainer.firstChild);

				// 限制日志数量
				if (logContainer.children.length > 50) {
					logContainer.removeChild(logContainer.lastChild);
				}

				state.logs.unshift({
					timestamp,
					message
				});
			}

			// 是否已拥有某号碎片
			function hasFragment(n) {
				return state.ownedFragments.includes(n);
			}

			// 下一片缺失的碎片编号（1~25）
			function nextMissing() {
				for (let i = 1; i <= 25; i++)
					if (!hasFragment(i)) return i;
				return 26; // 已齐
			}

			// 240 抽后对最后三片统一给高概率（线性 5%→95%）
			function lateFragmentP(n) {
				if (n < 240) return 0.01; // 240 前几乎不掉
				if (n > 270) return 1; // 271 起强制
				const t = n - 240; // 0~30
				return 0.05 + 0.9 * t / 30; // 5%→95%
			}

			// 执行单次抽取
			function performSingleDraw() {
				state.drawCount++;

				if (state.ownedFragments.length >= 25) {
					addLog(`第${state.drawCount}抽：已集齐所有碎片，无需再抽`);
					return;
				}

				const target = nextMissing(); // 1~25，顺序不掉跳

				let baseProbability;

				/* === 最后三片共享 soft-pity === */
				if (target >= 23) { // 23、24、25
					baseProbability = lateFragmentP(state.drawCount);
				} else {
					/* === 1~22 片：原表 === */
					baseProbability = fragmentProbabilities[target] / 100;
				}

				// 300 抽终极兜底（冗余，但保留）
				if (state.drawCount >= 300 && state.ownedFragments.length < 25) {
					baseProbability = 1;
				}

				const got = Math.random() < baseProbability;
				if (got) {
					state.ownedFragments.push(target);
					if (target === 25) {
						addLog(`第${state.drawCount}抽：<span style="color:#e74c3c;font-weight:bold;">获得终极碎片 #25！</span>`);
						updateFragmentsGrid();
						updateStats();
						setTimeout(() => {
							epicPopup.style.display = 'flex';
						}, 500);
						return;
					}
					addLog(`第${state.drawCount}抽：获得碎片 #${target}`);
					updateFragmentsGrid();
				} else {
					addLog(`第${state.drawCount}抽：未获得新碎片`);
				}
				updateStats();
			}

			// 生成横向概率条
			function renderProbBars() {
				const wrap = document.getElementById('prob-bars');
				const list = [{
						own: 0,
						prob: 100
					}, {
						own: 1,
						prob: 100
					}, {
						own: 2,
						prob: 96
					}, {
						own: 3,
						prob: 92
					},
					{
						own: 4,
						prob: 88
					}, {
						own: 5,
						prob: 84
					}, {
						own: 6,
						prob: 80
					}, {
						own: 7,
						prob: 76
					},
					{
						own: 8,
						prob: 72
					}, {
						own: 9,
						prob: 68
					}, {
						own: 10,
						prob: 64
					}, {
						own: 11,
						prob: 42.86
					},
					{
						own: 12,
						prob: 40
					}, {
						own: 13,
						prob: 37.14
					}, {
						own: 14,
						prob: 34.29
					}, {
						own: 15,
						prob: 31.43
					},
					{
						own: 16,
						prob: 25
					}, {
						own: 17,
						prob: 22.5
					}, {
						own: 18,
						prob: 20
					}, {
						own: 19,
						prob: 17.5
					},
					{
						own: 20,
						prob: 15
					}, {
						own: 21,
						prob: 2.44
					}, {
						own: 22,
						prob: 1.95
					}, {
						own: 23,
						prob: 1.46
					},
					{
						own: 24,
						prob: 0.98
					}
				];

				let tableHTML = '<table class="prob-table">';

				// 每行显示4个概率项
				for (let i = 0; i < list.length; i += 4) {
					tableHTML += '<tr>';
					for (let j = 0; j < 4; j++) {
						if (i + j < list.length) {
							const item = list[i + j];
							tableHTML += `
			          <td>
			            <div class="prob-label">${item.own}片</div>
			            <div class="prob-value">${item.prob}%</div>
			          </td>
			        `;
						} else {
							tableHTML += '<td></td>';
						}
					}
					tableHTML += '</tr>';
				}

				tableHTML += '</table>';
				wrap.innerHTML = tableHTML;
			}
			// 页面加载后渲染
			document.addEventListener('DOMContentLoaded', () => {
				renderProbBars(); // 概率条
			});


			// 执行多次抽取
			function performMultipleDraws(count) {
				for (let i = 0; i < count; i++) {
					// 如果已经集齐所有碎片，停止抽取
					if (state.ownedFragments.length >= 25) {
						addLog(`已集齐所有碎片，停止抽取`);
						break;
					}
					performSingleDraw();
				}
			}

			/* 4. 核心测试逻辑 */
			async function bulkTest_25() {
				const buckets = {
					'25-50': 0,
					'51-100': 0,
					'101-199': 0,
					'200-249': 0,
					'250': 0,
					'251-270': 0,
					'271-280': 0,
					'281-299': 0,
					'300': 0
				};
				const allDraws = []; // 每次周期抽数
				let minDraw = Infinity,
					maxDraw = -Infinity;
				let totalDraws = 0; // 总抽数

				/* 单次周期：抽到25#即结束 */
				function oneCycle() {
					const st = {
						drawCount: 0,
						owned: 0
					};
					while (st.owned < 25) {
						st.drawCount++;
						const target = st.owned + 1;
						let p;
						if (target >= 23) p = lateFragmentP(st.drawCount);
						else p = fragmentProbabilities[target] / 100;
						if (st.drawCount >= 300) p = 1;
						if (Math.random() < p) st.owned++;
					}
					return st.drawCount;
				}

				/* 跑 100 万周期，分块防假死 */
				const block = 100000;
				for (let k = 0; k < 10; k++) {
					for (let i = 0; i < block; i++) {
						const d = oneCycle();
						allDraws.push(d);
						totalDraws += d;
						/* 分桶 */
						if (d <= 50) buckets['25-50']++;
						else if (d <= 100) buckets['51-100']++;
						else if (d <= 199) buckets['101-199']++;
						else if (d <= 249) buckets['200-249']++;
						else if (d === 250) buckets['250']++;
						else if (d <= 270) buckets['251-270']++;
						else if (d <= 280) buckets['271-280']++;
						else if (d <= 299) buckets['281-299']++;
						else buckets['300']++;

						if (d < minDraw) minDraw = d;
						if (d > maxDraw && d < 300) maxDraw = d; // 300不计入“最多”
					}
					/* 让出 UI 线程 */
					await new Promise(resolve => setTimeout(resolve, 0));
				}

				/* 统计 */
				allDraws.sort((a, b) => a - b);
				const mid = allDraws[allDraws.length >> 1];
				const freq = {};
				let mode = allDraws[0],
					modeCount = 0;
				allDraws.forEach(v => {
					freq[v] = (freq[v] || 0) + 1;
					if (freq[v] > modeCount) {
						modeCount = freq[v];
						mode = v;
					}
				});
				const medianCount = freq[mid] || 0;

				/* 5. 渲染表格 */
				const tbl = document.getElementById('bulk-result-table');
				const row = (k, v, pct) => `<tr><td>${k}</td><td>${v.toLocaleString()}</td><td>${pct}</td></tr>`;
				let html = '';
				Object.entries(buckets).forEach(([k, v]) => {
					html += row(k + ' 抽', v, (v / 10000).toFixed(2) + '%');
				});
				html += row('最少抽中次数', 1, '');
				html += row('最少抽数', minDraw, '');
				html += row('最多抽中次数（除300）', 1, '');
				html += row('最多抽数（除300）', maxDraw, '');
				html += row('众数', mode, '');
				html += row('众数出现次数', modeCount, (modeCount / 10000).toFixed(2) + '%');
				html += row('中位数', mid, '');
				html += row('中位数出现次数', medianCount, (medianCount / 10000).toFixed(2) + '%');
				html += row('总抽数', totalDraws, '');
				html += row('平均抽数', (totalDraws / allDraws.length).toFixed(2), '');
				tbl.innerHTML = html;

				/* 6. 显示结果 */
				document.getElementById('bulk-result-modal').style.display = 'flex';
			}

			/* 7. 绑定按钮 */
			document.getElementById('bulk-test-btn').onclick = () => {
				document.getElementById('bulk-confirm-modal').style.display = 'flex';
			};
			document.getElementById('bulk-confirm-yes').onclick = () => {
				document.getElementById('bulk-confirm-modal').style.display = 'none';
				bulkTest_25();
			};
			document.getElementById('bulk-confirm-no').onclick = () => {
				document.getElementById('bulk-confirm-modal').style.display = 'none';
			};
			document.getElementById('bulk-close-result').onclick = () => {
				document.getElementById('bulk-result-modal').style.display = 'none';
			};
			document.getElementById('bulk-retest-btn').onclick = () => {
				document.getElementById('bulk-result-modal').style.display = 'none';
				bulkTest_25();
			};

			(function makeDraggable() {
				const handle = document.querySelector('.drag-handle');
				const box = document.querySelector('.draggable');
				let dx = 0,
					dy = 0,
					x0 = 0,
					y0 = 0;
				handle.onmousedown = e => {
					e.preventDefault();
					x0 = e.clientX;
					y0 = e.clientY;
					document.onmousemove = move;
					document.onmouseup = () => document.onmousemove = null;
				};

				function move(e) {
					dx = x0 - e.clientX;
					dy = y0 - e.clientY;
					x0 = e.clientX;
					y0 = e.clientY;
					box.style.top = (box.offsetTop - dy) + 'px';
					box.style.left = (box.offsetLeft - dx) + 'px';
				}
			})();

			const isWin = navigator.platform.toLowerCase().includes('win');
			if (!isWin) {
				document.getElementById('bulk-export-txt').classList.add('disabled');
			}

			document.getElementById('bulk-export-txt').addEventListener('click', () => {
				if (!isWin) return alert('仅限 Windows 系统使用！');
				document.getElementById('bulk-export-confirm').style.display = 'flex';
			});

			document.getElementById('bulk-export-no').addEventListener('click', () => {
				document.getElementById('bulk-export-confirm').style.display = 'none';
			});

			document.getElementById('bulk-export-yes').addEventListener('click', () => {
				const rows = Array.from(
					document.querySelectorAll('#bulk-result-table tr')
				).map(tr =>
					Array.from(tr.querySelectorAll('td, th'))
					.map(td => td.textContent.trim())
					.join('\t')
				).join('\r\n');

				const head = '梦之回廊模拟器 - 百万次25号碎片测试结果\r\n' +
					'生成时间：' + new Date().toLocaleString() + '\r\n\r\n';
				const blob = new Blob([head + rows], {
					type: 'text/plain;charset=utf-8'
				});

				const a = document.createElement('a');
				a.href = URL.createObjectURL(blob);
				a.download = '梦之回廊_百万测试.txt';
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);

				document.getElementById('bulk-export-confirm').style.display = 'none';
			});



			// 重置状态
			function resetState() {
				state = {
					drawCount: 0,
					ownedFragments: [],
					logs: []
				};

				updateFragmentsGrid();
				updateStats();
				logContainer.innerHTML = '';
				addLog('抽奖已重置');
			}

			// 初始化
			function init() {
				initFragmentsGrid();
				updateStats();
				addLog('抽奖模拟器已就绪');

				// 绑定事件
				document.getElementById('draw-1').addEventListener('click', () => performMultipleDraws(1));
				document.getElementById('draw-10').addEventListener('click', () => performMultipleDraws(10));
				document.getElementById('draw-30').addEventListener('click', () => performMultipleDraws(30));
				document.getElementById('reset-btn').addEventListener('click', resetState);
				closePopupBtn.addEventListener('click', () => {
					epicPopup.style.display = 'none';
				});

				// 点击弹窗外部关闭
				epicPopup.addEventListener('click', (e) => {
					if (e.target === epicPopup) {
						epicPopup.style.display = 'none';
					}
				});
			}

			document.addEventListener('DOMContentLoaded', function() {
				const toggleBtn = document.getElementById('toggle-explanation');
				const content = document.getElementById('explanation-content');
				const toggleIcon = toggleBtn.querySelector('.toggle-icon');

				toggleBtn.addEventListener('click', function() {
					content.classList.toggle('expanded');
					toggleIcon.textContent = content.classList.contains('expanded') ? '▲' : '▼';
				});
			});

			// 页面加载完成后初始化
			document.addEventListener('DOMContentLoaded', init);
		</script>
	</body>
</html>
