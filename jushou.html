<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<script src="js/card.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
		<title>æ²®çˆ¹çº¢åˆ©æœŸæ¨¡æ‹Ÿå™¨</title>
		<link rel="stylesheet" href="css/head.css">
	</head>
	<body>
		<div class="header">
			<p>æ“ä½œå°</p>
			<button id="reloadButton"
				style="margin-left: 15px; background-color: #ff4444; color: white;">å¼ºåˆ¶åˆ·æ–°ï¼ˆQï¼‰</button>
			<button id="draw1Button">å‘1å¼ ç‰Œï¼ˆ1ï¼‰</button>
			<button id="draw2Button">å‘2å¼ ç‰Œï¼ˆ2ï¼‰</button>
			<button id="draw3Button">å‘3å¼ ç‰Œï¼ˆ3ï¼‰</button>
			<button id="draw4Button">å‘4å¼ ç‰Œï¼ˆ4ï¼‰</button>
			<button id="revealButton">æŸ¥çœ‹å‰©ä½™ç‰Œå †ï¼ˆWï¼‰</button>
			<button id="highlightButton">é«˜äº®è¯¸è‘›è¿å¼©ï¼ˆEï¼‰</button>
			<button id="shuffleButton">é‡æ–°æ´—ç‰Œï¼ˆRï¼‰</button>
			<button id="reshuffleBtn" disabled>ä½¿ç”¨è„šæ°”å¡ï¼ˆTï¼‰</button>
			<button id="drawBtn">è¿›å…¥æ‘¸ç‰Œé˜¶æ®µï¼ˆAï¼‰</button>
			<button id="playBtn" disabled>è¿›å…¥å‡ºç‰Œé˜¶æ®µï¼ˆSï¼‰</button>
			<button id="endPlayBtn" disabled>ç»“æŸå‡ºç‰Œé˜¶æ®µï¼ˆDï¼‰</button>
			<button id="testCardBtn">æµ‹è¯•åŠŸèƒ½ï¼šæ·»åŠ æŒ‡å®šç‰Œ</button>
			<button id="testUniformBtn">æ´—ç‰Œå‡åŒ€æ€§æµ‹è¯•</button>
			<button id="testPerfBtn">æ´—ç‰Œæ€§èƒ½æµ‹è¯•ï¼ˆæš‚æœªç¼–å†™ä»£ç ï¼‰</button>
		</div>
		<div class="header-placeholder"></div>
		<h1>æ²®çˆ¹çº¢åˆ©æœŸæ¨¡æ‹Ÿå™¨V5.0</h1>

		<div class="tooltip-container">
			<div class="nav-buttons">
				<button class="nav-button"><a href="index.html">è¿”å›ä¸»é¡µ</a></button>
				<button class="nav-button"><a href="versionjs.html">è·³è½¬åˆ°æ›´æ–°æ—¥å¿—ï¼ˆåŸæ›´æ–°æ—¥å¿—å·²è¿ç§»åˆ°ä¸“å±ç½‘é¡µï¼‰</a></button>
			</div>
		</div>
		<p>è¯´æ˜ï¼šæœ¬ä»£ç çš„ç‰Œå †æ˜¯çœŸæ­£çš„çº¯éšæœºï¼Œä¸“æ²»å„ç§å˜´ç¡¬<br />
			è¯·å…ˆæŸ¥çœ‹å‰©ä½™ç‰Œå †ï¼Œå†ç‚¹é«˜äº®akã€‚<br />
			ç”±äºæ˜¯çº¯éšæœºåºåˆ—ï¼Œæœ‰ä¸€å¤§å †æ€é—ªæ‰å †å±äºæ­£å¸¸ç°è±¡ï¼ˆæ­å–œä½ åˆ·åˆ°äº†æ²™æ‘©æŸ¯çš„ç‰Œå †ï¼ˆbushiï¼‰ï¼‰ï¼Œä¸æƒ³çœ‹åˆ°æ­¤ç±»æƒ…å†µçš„ï¼Œé‡æ–°æ´—ç‰Œå³å¯<br />
			åˆ·æ–°æŒ‰é’®å¯åœ¨ç½‘é¡µæœ‰ä¸å¯é€†çš„bugæ—¶å°†ç½‘é¡µæ¢å¤åˆ°åˆå§‹çŠ¶æ€
		</p>
		<h2>å®‰å…¨æ ¡éªŒåŒºMD5/AESç¼–ç <button id="toggleMD5AES" style="font-size: 12px; padding: 2px 5px;">â–¼ æ”¶èµ·</button></h2>
		<div id="md5aes-container">
			<div class="md5-panel">
				<div class="md5-display">
					<div id="md5Value">******</div>
					<div class="md5-buttons">
						<button id="toggleMD5" class="md5-button">æ˜¾ç¤ºMD5</button>
						<button id="copyMD5" class="md5-button">å¤åˆ¶</button>
					</div>
				</div>
				<p class="md5-caption">è¯¥æ ‡è¯†ç¬¦åŸºäºå½“å‰ç‰Œå †ç”Ÿæˆï¼Œç”¨äºéªŒè¯ç‰Œå †å”¯ä¸€æ€§</p>
				<div class="verify-panel">
					<input type="text" id="verifyMD5" placeholder="è¾“å…¥MD5éªŒè¯ç‰Œå †" class="verify-input">
					<button onclick="verifyDeck()" class="md5-button">éªŒè¯</button>
					<span id="verifyResult" class="verify-result"></span>
				</div>
			</div>
			<div class="aes-panel">
				<div class="md5-display">
					<div id="aesValue" class="aes-value">******</div>
					<div class="md5-buttons">
						<button id="toggleAES" class="md5-button">æ˜¾ç¤ºAES</button>
						<button id="copyAES" class="md5-button">å¤åˆ¶</button>
					</div>
				</div>
				<p class="aes-caption">åŒ…å«å¯†é’¥çš„AESç¼–ç ï¼Œå¯åå‘è§£æç‰Œå †</p>
				<div class="verify-panel">
					<input type="text" id="verifyAES" placeholder="è¾“å…¥AESç¼–ç éªŒè¯ç‰Œå †" class="verify-input">
					<button onclick="verifyAESDeck()" class="md5-button">è§£å¯†éªŒè¯</button>
					<span id="verifyAESResult" class="verify-result"></span>
				</div>
				<div class="log-panel">
					<button id="exportLog" class="md5-button log-button">
						ğŸ“„ ç”Ÿæˆå®‰å…¨æ—¥å¿—æ–‡ä»¶
					</button>
				</div>
			</div>
		</div>
		<h2>è®°ç‰Œå™¨ <button id="toggleCounter" style="font-size: 12px; padding: 2px 5px;">â–¼ æ”¶èµ·</button></h2>
		<div id="remaining-counts"></div>
		<h3>çŠ¶æ€ä¿¡æ¯</h3>
		<div id="status-area">
			<div id="kill-counter">æ€å¯ç”¨æ¬¡æ•°ï¼š2</div>
			<div id="zhuge-status">è¯¸è‘›è¿å¼©ï¼šæœªè£…å¤‡</div>
			<div id="peach-counter">æ¡ƒå¯ç”¨æ¬¡æ•°ï¼š1</div>
			<div id="wine-counter">é…’å¯ç”¨æ¬¡æ•°ï¼š1</div>
		</div>
		<div id="testProgress" style="display:none;">
			<progress value="0" max="100"></progress>
			<span>0%</span>
		</div>
		<div id="deck"></div>
		<div id="remaining"></div>
		<div id="hand"></div>
		<h3>æ“ä½œæ—¥å¿—</h3>
		<div id="log-container">
			<div id="log"></div>
		</div>
		<div id="stageInfo" class="phase"></div>
		<script>
			let deck = [];
			let drawnCards = [];
			let discardPile = [];
			let hand = [];
			let phase = '';
			let lastUsedCard = null;
			let reshuffleUsed = 0;
			const MAX_RESHUFLE = 7;
			let currentMD5 = '';
			let showMD5 = false;
			let currentAES = '';
			let showAES = false;
			let originalDeck = [];
			let isCounterCollapsed = false;
			let isMD5AESCollapsed = false;
			let killCount = 2;
			let hasZhugeLianNu = false;
			let currentWeapon = null;
			let peachCount = 1;
			let wineCount = 1;

			function initializeDeck() {
				document.getElementById('log').innerHTML = '';
				log("ç‰Œå †åˆå§‹åŒ–å¼€å§‹");
				deck = [];
				drawnCards = [];
				discardPile = [];
				hand = [];
				document.getElementById('deck').innerHTML = '';
				reshuffleUsed = 0;
				phase = '';
				lastUsedCard = null;
				peachCount = 1;
				wineCount = 1;

				// ä½¿ç”¨å¤–éƒ¨å®šä¹‰çš„ standardDeck
				standardDeck.forEach(card => {
					card.suits.forEach(suitStr => {
						const match = suitStr.match(/^([â™ â™ â™¥â™£â™£â™¦]ï¸?)([JQKA]|\d+)$/);
						if (match) {
							const suitPart = match[1];
							let point = match[2];
							switch (point) {
								case 'J':
									point = 11;
									break;
								case 'Q':
									point = 12;
									break;
								case 'K':
									point = 13;
									break;
								case 'A':
									point = 1;
									break;
								default:
									point = parseInt(point, 10);
							}
							for (let i = 0; i < card.count; i++) {
								deck.push({
									name: card.name,
									suit: suitPart,
									point: point,
									uid: CryptoJS.lib.WordArray.random(16).toString()
								});
							}
						}
					});
				});

				currentWeapon = null;
				killCount = 2;
				hasZhugeLianNu = false;
				updateStatus();
				shuffleDeck();
				generateDeckMD5();
				updateMD5Display();
				generateDeckAES();
				updateAESDisplay();
				updateRemaining();
				startGame();
				log("ç‰Œå †åˆå§‹åŒ–å®Œæˆ");
			}


			function getPointDisplay(point) {
				switch (point) {
					case 11:
						return 'J';
					case 12:
						return 'Q';
					case 13:
						return 'K';
					case 1:
						return 'A';
					default:
						return point;
				}
			}

			function generateDeckMD5() {
				const deckString = deck
					.sort((a, b) => a.uid.localeCompare(b.uid))
					.map(c => `${c.name}|${c.suit}|${c.point}|${c.uid}`)
					.join('@@');
				const firstHash = CryptoJS.MD5(deckString).toString();
				const timestamp = Date.now().toString(16).padStart(16, '0');
				currentMD5 = CryptoJS.MD5(firstHash + timestamp).toString();
				const isDebug = new URLSearchParams(window.location.search).has('debug');
				currentMD5 = isDebug ? firstHash : CryptoJS.MD5(firstHash + timestamp).toString();
				if (isDebug) console.log("è°ƒè¯•æ¨¡å¼MD5ï¼ˆä¸å«æ—¶é—´æˆ³ï¼‰:", currentMD5);
			}
			const deckSnapshots = {};

			function saveSnapshot() {
				const snapshot = {
					deck: deck.map(c => ({
						...c
					})),
					md5: currentMD5,
					timestamp: Date.now()
				};
				deckSnapshots[currentMD5] = snapshot;
				localStorage.setItem('md5Snapshots', JSON.stringify(deckSnapshots));
				log(`ç‰Œå †å¿«ç…§å·²ä¿å­˜ (MD5: ${currentMD5})`);
			}

			function loadSnapshot(targetMD5) {
				const snapshot = deckSnapshots[targetMD5];
				if (!snapshot) return alert("æ— æ­¤ç‰Œå †è®°å½•");
				deck = snapshot.deck;
				currentMD5 = snapshot.md5;
				updateUI();
				log(`å·²åŠ è½½ç‰Œå †å¿«ç…§ (MD5: ${targetMD5})`);
			}

			function updateMD5Display() {
				const display = document.getElementById('md5Value');
				if (showMD5) {
					const formatted = currentMD5
						.match(/.{1,4}/g)
						.join('-')
						.toUpperCase();
					display.textContent = formatted;
					display.style.color = '#2196F3';
				} else {
					display.textContent = '******';
					display.style.color = '#666';
				}
			}
			document.getElementById('toggleMD5').addEventListener('click', () => {
				showMD5 = !showMD5;
				document.getElementById('toggleMD5').textContent =
					showMD5 ? 'éšè—MD5' : 'æ˜¾ç¤ºMD5';
				updateMD5Display();
			});
			document.getElementById('copyMD5').addEventListener('click', () => {
				if (!currentMD5) return;
				const copy = async () => {
					try {
						await navigator.clipboard.writeText(currentMD5);
						document.getElementById('copyMD5').classList.add('copied');
						setTimeout(() => {
							document.getElementById('copyMD5').classList.remove('copied');
						}, 1000);
						log('MD5å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
					} catch (err) {
						const textarea = document.createElement('textarea');
						textarea.value = currentMD5;
						document.body.appendChild(textarea);
						textarea.select();
						document.execCommand('copy');
						document.body.removeChild(textarea);
						log('MD5å·²å¤åˆ¶ï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰');
					}
				};
				copy().catch(err => {
					console.error('å¤åˆ¶å¤±è´¥:', err);
					log('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶');
				});
			});

			function verifyDeck() {
				const inputMD5 = document.getElementById('verifyMD5').value.replace(/-/g, '').toLowerCase();
				const isValid = currentMD5 === inputMD5;
				const resultSpan = document.getElementById('verifyResult');
				resultSpan.textContent = isValid ? 'âœ… éªŒè¯é€šè¿‡' : 'âŒ éªŒè¯å¤±è´¥';
				resultSpan.style.color = isValid ? '#4CAF50' : '#f44336';
				log(`ç‰Œå †MD5éªŒè¯${isValid ? 'æˆåŠŸ' : 'å¤±è´¥'}`);
			}

			function generateDeckAES() {
				try {
					const deckData = deck.map(c => ({
						n: c.name,
						s: c.suit,
						p: c.point,
						u: c.uid
					}));
					const key = CryptoJS.lib.WordArray.random(128 / 8);
					const iv = CryptoJS.lib.WordArray.random(128 / 8);
					const encrypted = CryptoJS.AES.encrypt(
						JSON.stringify(deckData),
						key, {
							iv: iv
						}
					);
					currentAES = [
						key.toString(CryptoJS.enc.Base64),
						iv.toString(CryptoJS.enc.Base64),
						encrypted.toString()
					].join('::');
				} catch (e) {
					console.error('AESç”Ÿæˆå¤±è´¥:', e);
					currentAES = 'ERROR';
				}
			}

			function updateAESDisplay() {
				const display = document.getElementById('aesValue');
				if (!display) return;
				if (showAES) {
					const formatted = currentAES
						.match(/.{1,24}/g)
						.join('\n');
					display.textContent = formatted;
					display.style.color = '#2196F3';
				} else {
					display.textContent = '******';
					display.style.color = '#666';
				}
			}
			document.getElementById('toggleAES').addEventListener('click', () => {
				showAES = !showAES;
				document.getElementById('toggleAES').textContent =
					showAES ? 'éšè—AES' : 'æ˜¾ç¤ºAES';
				updateAESDisplay();
			});
			document.getElementById('copyAES').addEventListener('click', () => {
				if (!currentAES || currentAES === '******') return;
				const copy = async () => {
					try {
						await navigator.clipboard.writeText(currentAES);
						document.getElementById('copyAES').classList.add('copied');
						setTimeout(() => {
							document.getElementById('copyAES').classList.remove('copied');
						}, 1000);
						log('AESç¼–ç å·²å¤åˆ¶');
					} catch (err) {
						const textarea = document.createElement('textarea');
						textarea.value = currentAES;
						document.body.appendChild(textarea);
						textarea.select();
						document.execCommand('copy');
						document.body.removeChild(textarea);
						log('AESç¼–ç å·²å¤åˆ¶ï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰');
					}
				};
				copy().catch(err => {
					console.error('å¤åˆ¶å¤±è´¥:', err);
					log('AESå¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶');
				});
			});

			function verifyAESDeck() {
				const input = document.getElementById('verifyAES').value.trim();
				const resultSpan = document.getElementById('verifyAESResult');
				if (!input) {
					resultSpan.textContent = 'âŒ è¯·è¾“å…¥ç¼–ç ';
					resultSpan.style.color = '#f44336';
					return;
				}
				try {
					const [keyB64, ivB64, data] = input.split('::');
					if (!keyB64 || !ivB64 || !data) throw new Error('æ ¼å¼æ— æ•ˆ');
					const key = CryptoJS.enc.Base64.parse(keyB64);
					const iv = CryptoJS.enc.Base64.parse(ivB64);
					const decrypted = CryptoJS.AES.decrypt(data, key, {
						iv: iv
					});
					const utf8String = decrypted.toString(CryptoJS.enc.Utf8);
					if (!utf8String) throw new Error('è§£å¯†å¤±è´¥');
					const decoded = JSON.parse(utf8String);
					deck = decoded.map(c => ({
						name: c.n,
						suit: c.s,
						point: c.p,
						uid: c.u
					}));
					generateDeckMD5();
					updateMD5Display();
					updateRemaining();
					revealDeck();
					log('AESè§£ç æˆåŠŸï¼Œç‰Œå †å·²åŠ è½½');
					resultSpan.textContent = 'âœ… éªŒè¯é€šè¿‡';
					resultSpan.style.color = '#4CAF50';
				} catch (e) {
					console.error('AESéªŒè¯å¤±è´¥:', e);
					resultSpan.textContent = 'âŒ æ— æ•ˆç¼–ç ';
					resultSpan.style.color = '#f44336';
					log('AESè§£ç å¤±è´¥: ' + e.message);
				}
			}

			function getSecureRandomIndex(max) {
				if (window.crypto && typeof window.crypto.getRandomValues === 'function') {
					const randomBuffer = new Uint32Array(1);
					window.crypto.getRandomValues(randomBuffer);
					return randomBuffer[0] % (max + 1);
				} else {
					return Math.floor(Math.random() * (max + 1));
				}
			}
			async function testShuffleUniformity() {
				const CONFIG = {
					TOTAL_TRIALS: 100000,
					BATCH_SIZE: 5000,
					DECK_SIZE: 160,
					AK_COUNT: 2,
					CHECK_SIZE: 7
				};
				const backdrop = document.createElement('div');
				backdrop.style.cssText = `
			        position: fixed;
			        top: 0;
			        left: 0;
			        right: 0;
			        bottom: 0;
			        background: rgba(0,0,0,0.5);
			        z-index: 9998;
			        backdrop-filter: blur(3px);
			    `;
				const panel = document.createElement('div');
				panel.className = 'scrollable-panel';
				panel.style.cssText = `
				    position: fixed;
				    top: 50%;
				    left: 50%;
				    transform: translate(-50%, -50%);
				    background: white;
				    padding: 25px;
				    border-radius: 12px;
				    box-shadow: 0 4px 20px rgba(0,0,0,0.25);
				    z-index: 9999;
				    width: 80%;
				    max-width: 800px;
				    max-height: 90vh;        // å…³é”®å±æ€§1ï¼šé™åˆ¶æœ€å¤§é«˜åº¦
				    overflow-y: auto;         // å…³é”®å±æ€§2ï¼šå¯ç”¨å‚ç›´æ»šåŠ¨
				    font-family: Arial, sans-serif;
				`;
				panel.innerHTML = `
			        <div style="position: relative; margin-bottom: 20px;">
			            <h2 style="margin:0 0 10px; color:#333; font-size:20px;">æ´—ç‰Œå‡åŒ€æ€§æµ‹è¯•</h2>
			            <div style="position: absolute; top: -15px; right: -15px; display: flex; gap: 5px;">
			                <button id="rerunTest" 
			                    style="padding: 8px 20px;
			                           background: #4CAF50;
			                           color: white;
			                           border: none;
			                           border-radius: 4px;
			                           cursor: pointer;">
			                    é‡æ–°æµ‹è¯• â–¶
			                </button>
			                <button id="closePanel" 
			                    style="padding: 8px 20px;
			                           background: #f44336;
			                           color: white;
			                           border: none;
			                           border-radius: 4px;
			                           cursor: pointer;">
			                    å…³é—­çª—å£ Ã—
			                </button>
			            </div>
			        </div>
			        <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:15px;">
			            <div>
			                <h3 style="font-size:14px; color:#666; margin:0 0 8px;">å®é™…ç»“æœ</h3>
			                <p>â‰¥1å¼ AKï¼š <span id="actualSingle">0</span></p>
			                <p>â‰¥2å¼ AKï¼š <span id="actualDouble">0</span></p>
			            </div>
			            <div>
			                <h3 style="font-size:14px; color:#666; margin:0 0 8px;">ç†è®ºå‚è€ƒ</h3>
			                <p>â‰ˆ8.51% (å•AK)</p>
			                <p>â‰ˆ0.165% (åŒAK)</p>
			            </div>
			        </div>
			        <div style="margin-top:20px; padding:15px; background:#f8f9fa; border-radius:6px;">
			            <!-- å•AKè®¡ç®—å…¬å¼ -->
			            <div style="margin-bottom:25px;">
			                <h4 style="color:#444; margin:0 0 8px; font-size:14px;">1. è‡³å°‘1å¼ è¯¸è‘›è¿å¼©ï¼ˆâ‰ˆ8.56%ï¼‰</h4>
			                <div style="font-family:monospace; font-size:14px;">
			                    <p style="margin:6px 0">N=160ï¼ˆæ€»ç‰Œæ•°ï¼‰</p>
			                    <p style="margin:6px 0">K=2ï¼ˆè¯¸è‘›è¿å¼©æ•°é‡ï¼‰</p>
			                    <p style="margin:6px 0">n=7ï¼ˆæŠ½ç‰Œæ•°ï¼‰</p>
			                    <p style="margin:4px 0;">P(â‰¥1) = 1 - [C(158,7) / C(160,7)]</p>
			                    <p style="margin:4px 0; color:#666;">      = 1 - 158ï¼/ ï¼ˆ7ï¼* 151ï¼ï¼‰/ 160ï¼/ï¼ˆ7ï¼ 8 153ï¼ï¼‰</p>
			                    <p style="margin:4px 0; color:#666;">      = 1 - (158Ã—157) / (160Ã—159)</p>
			                    <p style="margin:4px 0; color:#2196F3;">      â‰ˆ 8.51%</p>
			                </div>
			            </div>
			            <!-- åŒAKè®¡ç®—å…¬å¼ -->
			            <div style="margin-bottom:25px;">
			                <h4 style="color:#444; margin:0 0 8px; font-size:14px;">2. è‡³å°‘2å¼ è¯¸è‘›è¿å¼©ï¼ˆâ‰ˆ0.165%ï¼‰</h4>
			                <div style="font-family:monospace; font-size:14px;">
			                    <div style="margin-bottom:8px;">
			                        <p style="margin:4px 0;">è®¡ç®—å…¬å¼</p>
			                        <p style="margin:4px 0;">P (â‰¥2) = C ( K , 2 ) * C( N - K , n - 2) / C(N , n)</p>
			                        <p style="margin:4px 0;">P (=2) = C ( 2 , 2 ) * C( 158 , 5 ) / C (160 , 7)</P>
			                        <p style="margin:4px 0;">       = (1 * 158! / 5! * 153! ) / 160! / 7! * 153!</p>
			                        <p style="margin:4px 0;">P(â‰¥2) = [C(2,2)Â·C(158,5)] / C(160,7)</p>
			                        <p style="margin:4px 0; color:#666;">      = [1 Ã— (158Ã—157Ã—156Ã—155Ã—154)]</p>
			                        <p style="margin:4px 0; color:#666;">      / [160Ã—159Ã—158Ã—157Ã—156Ã—155Ã—154]</p>
			                    </div>
			                    <div style="border-left:3px solid #ddd; padding-left:12px; color:#666;">
			                        <p style="margin:4px 0;">åˆ†å­åŒ–ç®€ï¼š7Ã—6=42</p>
			                        <p style="margin:4px 0;">åˆ†æ¯åŒ–ç®€ï¼š160Ã—159=25,440</p>
			                        <p style="margin:4px 0; color:#2196F3;">æœ€ç»ˆâ‰ˆ42/25,440â‰ˆ0.165%</p>
			                    </div>
			                </div>
			            </div>
			        </div>
			        <progress value="0" max="${CONFIG.TOTAL_TRIALS}" 
			            style="width:100%; height:8px; margin:15px 0;"></progress>
			        <div id="akStats" style="color:#666; font-size:14px;"></div>
			    `;
				document.body.appendChild(panel);
				panel.style.cssText += `
				    ::-webkit-scrollbar {
				        width: 12px;  // å¢åŠ æ»šåŠ¨æ¡å®½åº¦
				    }
				    ::-webkit-scrollbar-track {
				        background: #f1f1f1;
				        border-radius: 10px;
				    }
				    ::-webkit-scrollbar-thumb {
				        background: #4CAF50;  // è®¾ç½®æ»šåŠ¨æ¡é¢œè‰²ä¸ºè“è‰²
				        border-radius: 10px;
				    }
				    ::-webkit-scrollbar-thumb:hover {
				        background: #3e8e41;  // æ»šåŠ¨æ¡æ‚¬åœæ—¶çš„é¢œè‰²
				    }
				`;
				document.body.appendChild(backdrop);
				document.body.appendChild(panel);
				let isClosing = false;
				let stats = {
					single: 0,
					double: 0
				};
				let completed = 0;
				const closePanel = () => {
					if (isClosing) return;
					isClosing = true;
					panel.style.transition = 'opacity 0.3s, transform 0.3s';
					panel.style.opacity = '0';
					panel.style.transform = 'translate(-50%, -50%) scale(0.9)';
					backdrop.style.transition = 'opacity 0.3s';
					backdrop.style.opacity = '0';
					setTimeout(() => {
						document.body.removeChild(backdrop);
						document.body.removeChild(panel);
					}, 300);
				};
				panel.querySelector('#closePanel').addEventListener('click', closePanel);
				panel.querySelector('#rerunTest').addEventListener('click', () => {
					closePanel();
					testShuffleUniformity();
				});
				const generateTestDeck = () =>
					Array.from({
						length: CONFIG.DECK_SIZE
					}, (_, i) => ({
						isAK: i < CONFIG.AK_COUNT,
						id: i
					}));
				const runBatch = async () => {
					for (let i = 0; i < CONFIG.BATCH_SIZE; i++) {
						if (isClosing) return;
						const deck = generateTestDeck();
						for (let j = deck.length - 1; j > 0; j--) {
							const k = Math.floor(Math.random() * (j + 1));
							[deck[j], deck[k]] = [deck[k], deck[j]];
						}
						const akCount = deck.slice(0, CONFIG.CHECK_SIZE)
							.filter(c => c.isAK).length;
						if (akCount >= 1) stats.single++;
						if (akCount >= 2) stats.double++;
					}
					completed += CONFIG.BATCH_SIZE;
					panel.querySelector('progress').value = completed;
					panel.querySelector('#actualSingle').textContent =
						`${stats.single} (${(stats.single / completed * 100).toFixed(2)}%)`;
					panel.querySelector('#actualDouble').textContent =
						`${stats.double} (${(stats.double / completed * 100).toFixed(2)}%)`;
					panel.querySelector('#akStats').innerHTML = `
			            <p>å·²æµ‹è¯•ï¼š${completed.toLocaleString()} æ¬¡</p>
			            <p>å•AKæ¦‚ç‡ï¼š${(stats.single / completed * 100).toFixed(2)}%</p>
			            <p>åŒAKæ¦‚ç‡ï¼š${(stats.double / completed * 100).toFixed(2)}%</p>
			        `;
				};
				try {
					const startTime = performance.now();
					while (completed < CONFIG.TOTAL_TRIALS && !isClosing) {
						await new Promise(resolve =>
							requestAnimationFrame(async () => {
								await runBatch();
								resolve();
							})
						);
					}
					if (!isClosing) {
						const totalTime = ((performance.now() - startTime) / 1000).toFixed(1);
						panel.querySelector('#akStats').innerHTML += `
			                <div style="margin-top:15px; padding-top:15px; border-top:1px solid #eee;">
			                    <p>æ€»è€—æ—¶ï¼š${totalTime} ç§’</p>
			                    <p>æµ‹è¯•ç‰Œå †ï¼š${CONFIG.DECK_SIZE}å¼ ï¼ˆå«${CONFIG.AK_COUNT}AKï¼‰</p>
			                </div>
			            `;
					}
				} catch (error) {
					console.error('æµ‹è¯•å‡ºé”™:', error);
					panel.querySelector('#akStats').innerHTML = `
			            <div style="color: red;">
			                <h3>æµ‹è¯•å¤±è´¥</h3>
			                <p>${error.message}</p>
			            </div>
			        `;
				}
			}
			document.getElementById('testPerfBtn').addEventListener('click', async () => {
				const confirmed = await showPerformanceWarning();
				if (confirmed) {
					testShuffleUniformity();
				}
			});

			function showPerformanceWarning() {
				return new Promise((resolve) => {
					const backdrop = document.createElement('div');
					backdrop.style.cssText = `
			            position: fixed;
			            top: 0;
			            left: 0;
			            right: 0;
			            bottom: 0;
			            background: rgba(0,0,0,0.6);
			            z-index: 9999;
			            display: flex;
			            justify-content: center;
			            align-items: center;
			        `;
					const alertBox = document.createElement('div');
					alertBox.style.cssText = `
			            background: white;
			            padding: 25px;
			            border-radius: 12px;
			            min-width: 400px;
			            max-width: 90vw;
			            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
			        `;
					alertBox.innerHTML = `
			            <h2 style="margin:0 0 15px; font-size:20px; color:#d32f2f;">âš ï¸ æ€§èƒ½è­¦å‘Š</h2>
			            <ul style="margin:0 0 20px; padding-left:20px;">
			                <li style="margin-bottom:8px;">CPUä½¿ç”¨ç‡å¯èƒ½è¾¾åˆ°100%</li>
			                <li style="margin-bottom:8px;">æµè§ˆå™¨å¯èƒ½æš‚æ—¶æ— å“åº”ï¼ˆçº¦10-30ç§’ï¼‰</li>
			                <li style="margin-bottom:8px;">ç§»åŠ¨è®¾å¤‡å¯èƒ½å‡ºç°æ˜æ˜¾å‘çƒ­</li>
			            </ul>
			            <div style="display: flex; gap:10px;">
			                <button id="confirmBtn" 
			                    style="flex:1; padding:12px; background:#4CAF50; 
			                           color:white; border:none; border-radius:6px;
			                           cursor:pointer;">ç»§ç»­æ‰§è¡Œ</button>
			                <button id="cancelBtn"
			                    style="flex:1; padding:12px; background:#f44336;
			                           color:white; border:none; border-radius:6px;
			                           cursor:pointer;">å–æ¶ˆæ“ä½œ</button>
			            </div>
			        `;
					const close = (result) => {
						document.body.removeChild(backdrop);
						resolve(result);
					};
					alertBox.querySelector('#confirmBtn').addEventListener('click', () => close(true));
					alertBox.querySelector('#cancelBtn').addEventListener('click', () => close(false));
					backdrop.addEventListener('click', (e) => {
						if (e.target === backdrop) close(false);
					});
					backdrop.appendChild(alertBox);
					document.body.appendChild(backdrop);
				});
			}

			function buildAKStats(total, single, double, totalAK) {
				const singleRate = (single / total * 100).toFixed(2);
				const doubleRate = (double / total * 100).toFixed(2);
				return `<div style="border-top:1px solid #ddd;padding-top:10px;">
			        <h4>è¯¸è‘›è¿å¼©ç»Ÿè®¡ï¼ˆç‰Œå †å…±${totalAK}å¼ ï¼‰</h4>
			        <p>å‰7å¼ å‡ºç°è‡³å°‘1å¼ ï¼š 
			            ${single.toLocaleString()}/${total.toLocaleString()}, 
			            ${singleRate}%</p>
			        <p>å‰7å¼ åŒæ—¶å‡ºç°2å¼ ï¼š 
			            ${double.toLocaleString()}/${total.toLocaleString()}, 
			            ${doubleRate}%</p>
			    </div>`;
			}

			function updateAKStats(progress, completed, single, double) {
				const statsDiv = progress.querySelector('#akStats');
				if (!statsDiv) return;
				const current = completed.toLocaleString();
				const singleRate = (single / completed * 100).toFixed(2);
				const doubleRate = (double / completed * 100).toFixed(2);
				statsDiv.innerHTML = `
			        <p>å®æ—¶ç»Ÿè®¡ï¼ˆå·²æµ‹è¯•${current}æ¬¡ï¼‰:</p>
			        <p>å•AKå‡ºç°ç‡: ${singleRate}%</p>
			        <p>åŒAKå‡ºç°ç‡: ${doubleRate}%</p>`;
			}

			function generateStandardDeck() {
				const deck = [];
				standardDeck.forEach(card => {
					card.suits.forEach(suitStr => {
						const match = suitStr.match(/^([â™ â™¥â™£â™¦]ï¸?)([JQKA]|\d+)$/);
						if (match) {
							const suitPart = match[1];
							let point = match[2];
							switch (point) {
								case 'J':
									point = 11;
									break;
								case 'Q':
									point = 12;
									break;
								case 'K':
									point = 13;
									break;
								case 'A':
									point = 1;
									break;
								default:
									point = parseInt(point, 10);
							}
							for (let i = 0; i < card.count; i++) {
								deck.push({
									name: card.name,
									suit: suitPart,
									point: point,
									uid: CryptoJS.lib.WordArray.random(16).toString()
								});
							}
						}
					});
				});
				return deck;
			}
			async function showPerformanceWarning(testFunction) {
				return new Promise((resolve) => {
					const alertBox = document.createElement('div');
					alertBox.className = 'security-alert';
					alertBox.innerHTML = `
			            <strong>æ€§èƒ½è­¦å‘Š</strong>
			            <p>å³å°†æ‰§è¡Œå‹åŠ›æµ‹è¯•ï¼Œå¯èƒ½ä¼šé€ æˆï¼šï¼ˆç³»ç»Ÿä¼šè‡ªåŠ¨è¿›è¡Œåä¸‡æ¬¡æ´—ç‰Œï¼ï¼ï¼ï¼‰</p>
			            <ul>
			                <li>â–¸ CPUä½¿ç”¨ç‡çŸ­æš‚é£™å‡</li>
			                <li>â–¸ æµè§ˆå™¨æš‚æ—¶æ— å“åº”ï¼ˆçº¦10-30ç§’ï¼‰</li>
			                <li>â–¸ ç§»åŠ¨è®¾å¤‡å¯èƒ½å‡ºç°æ˜æ˜¾å‘çƒ­</li>
			            </ul>
			            <p>å»ºè®®å…³é—­å…¶ä»–æ ‡ç­¾é¡µåç»§ç»­ï¼Œæ˜¯å¦ç¡®è®¤æ‰§è¡Œï¼Ÿ</p>
			            <button class="confirm">ç»§ç»­æ‰§è¡Œ</button>
			            <button class="cancel">å–æ¶ˆæ“ä½œ</button>
			        `;
					const backdrop = document.createElement('div');
					backdrop.className = 'modal-backdrop';
					const container = document.createElement('div');
					container.style.cssText = `
			            position: fixed;
			            top: 0;
			            left: 0;
			            width: 100%;
			            height: 100%;
			            display: flex;
			            justify-content: center;
			            align-items: center;
			        `;
					container.appendChild(alertBox);
					backdrop.appendChild(container);
					document.body.appendChild(backdrop);
					const handler = (result) => {
						document.body.removeChild(backdrop);
						resolve(result);
					};
					alertBox.querySelector('.confirm').addEventListener('click', () => handler(true));
					alertBox.querySelector('.cancel').addEventListener('click', () => handler(false));
					backdrop.addEventListener('click', (e) => {
						if (e.target === backdrop) handler(false);
					});
				});
			}

			function updateRemainingCounts() {
				const categories = {
					basic: {
						name: "åŸºæœ¬ç‰Œ",
						items: {}
					},
					trick: {
						name: "æ™®é€šé”¦å›Šç‰Œ",
						items: {}
					},
					ystrick: {
						name: "å»¶æ—¶é”¦å›Šç‰Œ",
						items: {}
					},
					weapon: {
						name: "æ­¦å™¨",
						items: {}
					},
					armor: {
						name: "é˜²å…·",
						items: {}
					},
					horse: {
						name: "åéª‘",
						items: {}
					}
				};

				deck.forEach(card => {
					// ä½¿ç”¨å¤–éƒ¨å®šä¹‰çš„ cardCategories
					for (const [type, items] of Object.entries(cardCategories)) {
						if (items.includes(card.name)) {
							categories[type].items[card.name] = (categories[type].items[card.name] || 0) + 1;
							break;
						}
					}
				});

				let html = '';
				for (const category of Object.values(categories)) {
					if (Object.keys(category.items).length === 0) continue;
					html += `<div class="category"><div class="category-title">${category.name}</div>`;
					const sorted = Object.entries(category.items)
						.sort((a, b) => a[0].localeCompare(b[0], 'zh-Hans-CN'));
					html += sorted.map(([name, count]) =>
						`<div class="count-item">${name}ï¼š${count}</div>`
					).join('');
					html += '</div>';
				}
				document.getElementById('remaining-counts').innerHTML = html;
			}

			function drawCards(count) {
				if (deck.length === 0) {
					alert("ç‰Œå †å·²ç©ºï¼Œæ— æ³•ç»§ç»­æŠ½ç‰Œï¼");
					return;
				}
				if (deck.length < count) {
					alert(`ç‰Œå †ä»…å‰©${deck.length}å¼ ï¼Œè‡ªåŠ¨æŠ½å–å…¨éƒ¨`);
					count = deck.length;
				}
				for (let i = 0; i < count; i++) {
					const drawnCard = deck.shift();
					drawnCards.push(drawnCard);
					hand.push(drawnCard);
					if (drawnCard.name === "è¯¸è‘›è¿å¼©") {
						alert(`æŠ½åˆ°AKï¼å‰©ä½™ç‰Œå †ï¼š${deck.length}å¼ `);
					}
				}
				updateRemaining();
				updateReshuffleButton();
				updateUI();
			}

			function revealDeck() {
				const container = document.getElementById('remaining');
				if (deck.length === 0) {
					container.innerHTML = `<h3>å‰©ä½™ç‰Œå † (0å¼ )</h3><p>ç‰Œå †å·²ç©º</p>`;
					return;
				}
				container.innerHTML = `<h3>å‰©ä½™ç‰Œå † (${deck.length}å¼ )</h3>`;
				deck.forEach((card, index) => {
					container.innerHTML += `
                   <div class="card">
                       ${index + 1}. ${card.name} ${card.suit}${getPointDisplay(card.point)}
                   </div>`;
				});
			}

			function highlightZhugeLianNu() {
				const remainingCards = document.querySelectorAll('#remaining .card');
				if (deck.length === 0) {
					alert("ç‰Œå †å·²ç©ºï¼Œæ²¡æœ‰è¯¸è‘›è¿å¼©ï¼");
					return;
				}
				const akCards = Array.from(remainingCards).filter(card =>
					card.textContent.includes('è¯¸è‘›è¿å¼©')
				);
				akCards.forEach(card => card.classList.add('highlight'));
				const indices = akCards.map(card =>
					Array.from(remainingCards).indexOf(card) + 1
				);
				indices.length > 0 ?
					alert(`è¯¸è‘›è¿å¼©ä½ç½®ï¼š${indices.join(', ')}`) :
					alert("å‰©ä½™ç‰Œå †ä¸­æ²¡æœ‰è¯¸è‘›è¿å¼©ï¼");
			}

			function updateRemaining() {
				document.getElementById('remaining').innerHTML = `å‰©ä½™ç‰Œå †: ${deck.length}å¼ `;
				updateRemainingCounts();
			}

			function handleReshuffle() {
				if (!validateReshuffle()) return;
				log(`å¼€å§‹ä½¿ç”¨è„šæ°”å¡ï¼ˆå½“å‰å·²ç”¨${reshuffleUsed}æ¬¡ï¼‰`);
				const currentDrawn = hand.splice(-4, 4);
				log(`å›æ”¶æ‰‹ç‰Œï¼š${currentDrawn.map(c => c.name).join(', ')}`);
				deck.unshift(...currentDrawn);
				shuffleDeck();
				reshuffleUsed++;
				log(`è„šæ°”å¡æ´—ç‰Œå®Œæˆï¼ˆ${reshuffleUsed}/${MAX_RESHUFLE}æ¬¡ï¼‰`);
				discardPile.push(...drawnCards);
				drawnCards = [];
				drawCards(4);
				log(`é‡æ–°æŠ½å–4å¼ ç‰Œï¼Œå‰©ä½™ç‰Œå †ï¼š${deck.length}å¼ `);
				updateCounter();
				updateReshuffleButton();
			}

			function validateReshuffle() {
				const isValid = hand.length === 4 &&
					reshuffleUsed < MAX_RESHUFLE &&
					deck.length + hand.length >= 4;
				if (!isValid) {
					log(`è„šæ°”å¡ä½¿ç”¨å¤±è´¥ï¼ŒéªŒè¯æ¡ä»¶ä¸æ»¡è¶³ï¼š
                 æ‰‹ç‰Œæ•°: ${hand.length}
                 å·²ç”¨æ¬¡æ•°: ${reshuffleUsed}
                 å‰©ä½™ç‰Œæ•°: ${deck.length}`);
				}
				return isValid;
			}

			function clearDisplay() {
				document.getElementById('deck').innerHTML = '';
			}

			function updateReshuffleButton() {
				const btn = document.getElementById('reshuffleBtn');
				btn.disabled = !(drawnCards.length === 4 && reshuffleUsed < MAX_RESHUFLE);
			}

			function shuffleDeck() {
				for (let i = deck.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[deck[i], deck[j]] = [deck[j], deck[i]];
				}
				if (!deck.some(c => c.name === currentWeapon)) {
					currentWeapon = null;
					hasZhugeLianNu = false;
					killCount = 2;
				}
				peachCount = 1;
				document.getElementById('peach-counter').textContent = `æ¡ƒå¯ç”¨æ¬¡æ•°ï¼š1`;
				wineCount = 1;
				updateStatus();
				generateDeckAES();
				updateAESDisplay();
			}

			function startGame() {
				drawCards(4);
				phase = 'å‡†å¤‡';
				document.getElementById('drawBtn').disabled = false;
				document.getElementById('playBtn').disabled = true;
				updateUI();
			}

			function initializeButtons() {
				document.getElementById('drawBtn').disabled = false;
				document.getElementById('playBtn').disabled = true;
			}

			function drawPhase() {
				if (deck.length === 0) {
					alert("ç‰Œå †å·²ç©ºï¼Œæ— æ³•æ‘¸ç‰Œï¼");
					return;
				}
				phase = 'æ‘¸ç‰Œ';
				drawCards(3);
				document.getElementById('drawBtn').disabled = true;
				document.getElementById('playBtn').disabled = false;
				updateUI();
			}

			function playPhase() {
				phase = 'å‡ºç‰Œ';
				lastUsedCard = null;
				document.getElementById('drawBtn').disabled = true;
				document.getElementById('playBtn').disabled = true;
				document.getElementById('endPlayBtn').disabled = false;
				updateUI();
			}

			function useCard(card, index) {
				if (phase !== 'å‡ºç‰Œ') return;
				log(`ä½¿ç”¨å¡ç‰Œï¼š${card.name} ${card.suit}${getPointDisplay(card.point)}`);
				if (cardCategories.weapon.includes(card.name)) {
					if (currentWeapon && currentWeapon !== card.name) {
						if (currentWeapon === "è¯¸è‘›è¿å¼©") {
							hasZhugeLianNu = false;
							killCount = 2;
							log(`å¸é™¤è¯¸è‘›è¿å¼©ï¼Œæ€æ¬¡æ•°é‡ç½®ä¸º2`);
						}
					}
					currentWeapon = card.name;
					hasZhugeLianNu = (card.name === "è¯¸è‘›è¿å¼©");
					if (hasZhugeLianNu) {
						log("è£…å¤‡è¯¸è‘›è¿å¼©ï¼Œæ€æ¬¡æ•°é™åˆ¶è§£é™¤");
					}
				}
				if (['æ€', 'ç«æ€', 'é›·æ€'].includes(card.name)) {
					if (!hasZhugeLianNu) {
						if (killCount <= 0) {
							alert("æ€æ¬¡æ•°å·²ç”¨å°½ï¼");
							return;
						}
						killCount--;
						log(`ä½¿ç”¨${card.name}ï¼Œå‰©ä½™æ¬¡æ•°ï¼š${killCount}`);
					}
				}
				if (card.name === "è¯¸è‘›è¿å¼©") {
					hasZhugeLianNu = true;
					log("è£…å¤‡è¯¸è‘›è¿å¼©ï¼Œæ€æ¬¡æ•°é™åˆ¶è§£é™¤ï¼");
				}
				if (card.name === "æ— ä¸­ç”Ÿæœ‰") {
					log('ä½¿ç”¨æ— ä¸­ç”Ÿæœ‰ï¼Œé¢å¤–æ‘¸ä¸¤å¼ ç‰Œï¼');
					drawCards(2);
				}
				if (card.name === 'é—ª') {
					alert("å‡ºç‰Œé˜¶æ®µç¦æ­¢ä½¿ç”¨é—ªï¼");
					return;
				}
				if (card.name === 'æ— æ‡ˆå¯å‡»') {
					alert("å‡ºç‰Œé˜¶æ®µç¦æ­¢ä½¿ç”¨æ— æ‡ˆå¯å‡»");
					return;
				}
				if (card.name === "é“ç´¢è¿ç¯") {
					showChainDialog(card, index);
					return;
				}
				if (card.name === "å€Ÿåˆ€æ€äºº") {
					showJiedaoDialog(card, index);
					return;
				}
				if (card.name === "æ¡ƒ") {
					if (peachCount <= 0) {
						alert("æ¡ƒä½¿ç”¨æ¬¡æ•°å·²è€—å°½ï¼");
						return;
					}
					peachCount--;
					log(`ä½¿ç”¨æ¡ƒï¼Œå‰©ä½™æ¬¡æ•°ï¼š${peachCount}`);
				}
				if (card.name === "æ¡ƒå›­ç»“ä¹‰") {
					peachCount = Math.max(peachCount - 1, 0);
					log(`ä½¿ç”¨æ¡ƒå›­ç»“ä¹‰æ¢å¤ä½“åŠ›ï¼Œå‰©ä½™æ¬¡æ•°ï¼š${peachCount}`);
				}
				if (card.name === "é…’") {
					if (wineCount <= 0) {
						alert("é…’ä½¿ç”¨æ¬¡æ•°å·²è€—å°½ï¼");
						return;
					}
					wineCount--;
					log(`ä½¿ç”¨é…’ï¼Œå‰©ä½™æ¬¡æ•°ï¼š${wineCount}`);
				}
				if (lastUsedCard && (card.suit === lastUsedCard.suit || card.point === lastUsedCard.point)) {
					log('è§¦å‘æ¸è¥ï¼Œæ‘¸ä¸€å¼ ç‰Œï¼');
					drawCards(1);
				}
				lastUsedCard = card;
				discardPile.push(hand.splice(index, 1)[0]);
				updateStatus();
				updateUI();
			}

			function updateStatus() {
				const counter = document.getElementById('kill-counter');
				const zhuge = document.getElementById('zhuge-status');
				document.getElementById('peach-counter').textContent = `æ¡ƒå¯ç”¨æ¬¡æ•°ï¼š${peachCount}`;
				document.getElementById('wine-counter').textContent = `é…’å¯ç”¨æ¬¡æ•°ï¼š${wineCount}`;
				counter.innerHTML = hasZhugeLianNu ?
					'æ€å¯ç”¨æ¬¡æ•°ï¼šâˆ' :
					`æ€å¯ç”¨æ¬¡æ•°ï¼š${killCount}`;

				zhuge.textContent = currentWeapon ?
					`å½“å‰æ­¦å™¨ï¼š${currentWeapon}` :
					"å½“å‰æ­¦å™¨ï¼šæ— ";
			}

			function showChainDialog(card, index) {
				const dialog = document.createElement('div');
				dialog.style = `
	           position: fixed;
	           top: 50%;
	           left: 50%;
	           transform: translate(-50%, -50%);
	           background: white;
	           padding: 20px;
	           border: 2px solid #666;
	           z-index: 10000;
	           box-shadow: 0 0 10px rgba(0,0,0,0.5);
	       `;
				dialog.innerHTML = `
	           <h3>é“ç´¢è¿ç¯æ•ˆæœé€‰æ‹©</h3>
	           <p>è¯·é€‰æ‹©è¦æ‰§è¡Œçš„æ“ä½œï¼š</p>
	           <button id="func1">åŠŸèƒ½1ï¼šé‡é“¸æ‘¸ç‰Œ</button>
	           <button id="func2">åŠŸèƒ½2ï¼šä½¿ç”¨æ£€ç´¢</button>
	           <button id="cancel">å–æ¶ˆ</button>
	       `;
				const overlay = document.createElement('div');
				overlay.style = `
	           position: fixed;
	           top: 0;
	           left: 0;
	           right: 0;
	           bottom: 0;
	           background: rgba(0,0,0,0.5);
	           z-index: 9999;
	       `;
				dialog.querySelector('#func1').addEventListener('click', () => {
					hand.splice(index, 1);
					discardPile.push(card);
					drawCards(1);
					log(`é‡é“¸é“ç´¢è¿ç¯ï¼Œæ‘¸1å¼ ç‰Œ`);
					cleanupDialog();
				});
				dialog.querySelector('#func2').addEventListener('click', () => {
					if (lastUsedCard && (card.suit === lastUsedCard.suit || card.point === lastUsedCard.point)) {
						log('è§¦å‘æ¸è¥ï¼Œæ‘¸ä¸€å¼ ç‰Œï¼');
						drawCards(1);
					}
					lastUsedCard = card;
					discardPile.push(hand.splice(index, 1)[0]);
					log(`ä½¿ç”¨é“ç´¢è¿ç¯ï¼ŒèŠ±è‰²${card.suit} ç‚¹æ•°${getPointDisplay(card.point)}`);
					cleanupDialog();
				});
				dialog.querySelector('#cancel').addEventListener('click', cleanupDialog);

				function cleanupDialog() {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
					updateUI();
				}
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
			}

			function showJiedaoDialog(card, index) {
				const overlay = document.createElement('div');
				overlay.className = 'modal-backdrop';
				const dialog = document.createElement('div');
				dialog.className = 'card-selector-modal';
				dialog.innerHTML = `
			        <h3>å€Ÿåˆ€æ€äººæ•ˆæœé€‰æ‹©</h3>
			        <p>è¯·é€‰æ‹©è¦æ‰§è¡Œçš„æ“ä½œï¼š</p>
			        <div style="display: flex; flex-direction: column; gap: 10px;">
			            <button id="func1" class="dialog-button">åŠŸèƒ½1ï¼šæ£€ç´¢æ­¦å™¨</button>
			            <button id="func2" class="dialog-button">åŠŸèƒ½2ï¼šä½¿ç”¨é—ª</button>
			            <button id="cancel" class="dialog-button cancel">å–æ¶ˆ</button>
			        </div>
			    `;
				const closeAllModals = () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
				};
				dialog.querySelector('#func1').addEventListener('click', () => {
					closeAllModals();
					const weaponCards = deck.filter(c => cardCategories.weapon.includes(c.name));
					if (weaponCards.length === 0) {
						alert("ç‰Œå †ä¸­æ²¡æœ‰æ­¦å™¨ç‰Œï¼");
						return;
					}
					const weaponCard = weaponCards[0];
					const deckIndex = deck.findIndex(c => c.uid === weaponCard.uid);
					if (deckIndex === -1) {
						logError(`æ­¦å™¨ç‰Œ ${weaponCard.name} ä¸å­˜åœ¨äºç‰Œå †ä¸­`);
						return;
					}
					const [removed] = deck.splice(deckIndex, 1);
					hand.push(removed);
					log(`æ£€ç´¢è·å¾—æ­¦å™¨ï¼š${removed.name} ${removed.suit}${getPointDisplay(removed.point)}`);
					finalizeJiedao(card, index);
				});
				dialog.querySelector('#func2').addEventListener('click', () => {
					closeAllModals();
					const shanCards = hand.filter(c => c.name === "é—ª");
					if (shanCards.length === 0) {
						showNoShanDialog(card, index);
					} else {
						showShanSelection(shanCards, card, index);
					}
					finalizeJiedao(card, index);
				});
				dialog.querySelector('#cancel').addEventListener('click', () => {
					closeAllModals();
					log("å–æ¶ˆä½¿ç”¨å€Ÿåˆ€æ€äºº");
				});
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
				overlay.addEventListener('click', (e) => {
					if (e.target === overlay) {
						closeAllModals();
						log("å–æ¶ˆä½¿ç”¨å€Ÿåˆ€æ€äºº");
					}
				});
			}

			function showNoShanDialog(card, index) {
				const dialog = document.createElement('div');
				dialog.className = 'card-selector-modal';
				dialog.innerHTML = `
			        <h3>æ²¡æœ‰é—ªç‰Œ</h3>
			        <p>è¯·é€‰æ‹©åç»­æ“ä½œï¼š</p>
			        <button class="dialog-button" id="cancelUse">å–æ¶ˆä½¿ç”¨</button>
			        <button class="dialog-button" id="noShan">åšæŒä¸å‡ºé—ª</button>
			    `;
				const overlay = document.createElement('div');
				overlay.className = 'modal-backdrop';
				dialog.querySelector('#cancelUse').addEventListener('click', () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
				});
				dialog.querySelector('#noShan').addEventListener('click', () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
					peachCount = Math.min(peachCount + 1, 3);
					log(`ä¸å‡ºé—ªï¼Œæ¡ƒå¯ç”¨æ¬¡æ•°+1ï¼Œå½“å‰ï¼š${peachCount}`);
					finalizeJiedao(card, index);
				});
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
			}

			function showShanSelection(shanCards, card, index) {
				const dialog = document.createElement('div');
				dialog.className = 'card-selector-modal';
				dialog.innerHTML = `
			        <h3>é€‰æ‹©è¦ä½¿ç”¨çš„é—ªç‰Œ</h3>
			        <div id="shanList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 15px 0;">
			            ${shanCards.map((c, i) => `
			                <button class="shan-card" data-index="${i}">
			                    ${c.suit}${getPointDisplay(c.point)}
			                </button>
			            `).join('')}
			        </div>
			        <button class="dialog-button cancel" id="cancelShan">å–æ¶ˆä½¿ç”¨é—ª</button>
			    `;
				const overlay = document.createElement('div');
				overlay.className = 'modal-backdrop';
				dialog.querySelectorAll('.shan-card').forEach(btn => {
					btn.addEventListener('click', (e) => {
						const idx = parseInt(e.target.dataset.index);
						const selectedCard = shanCards[idx];
						const handIndex = hand.findIndex(c => c.uid === selectedCard.uid);
						if (handIndex > -1) {
							const [removed] = hand.splice(handIndex, 1);
							discardPile.push(removed);
							log(`ä½¿ç”¨é—ªç‰Œï¼š${removed.suit}${getPointDisplay(removed.point)}`);
						}
						document.body.removeChild(overlay);
						document.body.removeChild(dialog);
						finalizeJiedao(card, index);
					});
				});
				dialog.querySelector('#cancelShan').addEventListener('click', () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
					peachCount = Math.min(peachCount + 1, 3);
					log(`å–æ¶ˆä½¿ç”¨é—ªï¼Œæ¡ƒå¯ç”¨æ¬¡æ•°+1ï¼Œå½“å‰ï¼š${peachCount}`);
					finalizeJiedao(card, index);
				});
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
			}

			function finalizeJiedao(card, index) {
				const jiedaoCard = hand.splice(index, 1)[0];
				discardPile.push(jiedaoCard);
				if (lastUsedCard && (jiedaoCard.suit === lastUsedCard.suit ||
						jiedaoCard.point === lastUsedCard.point)) {
					log('è§¦å‘æ¸è¥ï¼Œæ‘¸ä¸€å¼ ç‰Œï¼');
					drawCards(1);
				}
				lastUsedCard = jiedaoCard;
				updateUI();
				updateStatus();
			}

			function cleanupDialog() {
				const dialogs = document.querySelectorAll('.modal-backdrop, .card-selector-modal');
				dialogs.forEach(dialog => dialog.remove());
			}

			function updateUI() {
				const stageInfo = document.getElementById('stageInfo');
				if (stageInfo) {
					stageInfo.textContent = `å½“å‰é˜¶æ®µï¼š${phase}é˜¶æ®µ`;
				}
				const handDiv = document.getElementById('hand');
				handDiv.innerHTML = '<h3>æ‰‹ç‰Œ</h3>';
				hand.forEach((card, i) => {
					const div = document.createElement('div');
					div.className = 'card';
					if (['æ€', 'ç«æ€', 'é›·æ€'].includes(card.name)) {
						if (!hasZhugeLianNu && killCount <= 0) {
							div.classList.add('disabled');
						}
					}
					if (card.name === "æ¡ƒ" && peachCount <= 0) {
						div.classList.add('disabled');
					}
					if (card.name === "é…’" && wineCount <= 0) {
						div.classList.add('disabled');
					}
					if (card.name === 'é—ª') {
						div.classList.add('disabled');
						div.onclick = () => alert("å‡ºç‰Œé˜¶æ®µæ— æ³•ä½¿ç”¨é—ªï¼");
					}
					if (card.name === 'æ— æ‡ˆå¯å‡»') {
						div.classList.add('disabled');
						div.onclick = () => alert("å‡ºç‰Œé˜¶æ®µæ— æ³•ä½¿ç”¨æ— æ‡ˆå¯å‡»");
					}
					div.innerHTML = `${card.name}<br>${card.suit}${getPointDisplay(card.point)}`;
					div.onclick = () => useCard(card, i);
					handDiv.appendChild(div);
				});
				document.getElementById('playBtn').disabled = phase !== 'æ‘¸ç‰Œ';
				document.getElementById('endPlayBtn').disabled = phase !== 'å‡ºç‰Œ';
			}

			function endPlayPhase() {
				phase = 'å‡†å¤‡';
				lastUsedCard = null;
				document.getElementById('drawBtn').disabled = false;
				document.getElementById('endPlayBtn').disabled = true;
				document.getElementById('playBtn').disabled = true;
				if (currentWeapon !== "è¯¸è‘›è¿å¼©") {
					killCount = 2;
					hasZhugeLianNu = false;
				} else {
					hasZhugeLianNu = true;
					log("ä¿ç•™è¯¸è‘›è¿å¼©æ•ˆæœï¼Œæ€æ¬¡æ•°ä¿æŒæ— é™");
				}
				wineCount = 1;
				updateStatus();
				updateUI();
				log("å·²ç»“æŸå‡ºç‰Œé˜¶æ®µ");
			}

			function discardCard(card) {
				if (card.name === "è¯¸è‘›è¿å¼©") {
					hasZhugeLianNu = false;
					log("å¤±å»è¯¸è‘›è¿å¼©ï¼Œæ¢å¤æ¬¡æ•°é™åˆ¶");
					updateStatus();
				}

			}

			function updateHeaderPlaceholder() {
				const header = document.querySelector('.header');
				const placeholder = document.querySelector('.header-placeholder');
				if (header && placeholder) {
					const height = header.offsetHeight + 5;
					placeholder.style.height = `${height}px`;
				}
			}
			window.addEventListener('DOMContentLoaded', updateHeaderPlaceholder);
			window.addEventListener('resize', updateHeaderPlaceholder);

			function isWindowsOS() {
				return navigator.userAgent.indexOf('Win') > -1;
			}

			function generateSecurityLog() {
				const timeStamp = new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '');
				const deckDetails = deck.map((card, index) =>
					`[${index + 1}] ${card.name} - èŠ±è‰²:${card.suit} ç‚¹æ•°:${getPointDisplay(card.point)} UID:${card.uid}`
				).join('\n');
				return `æ²®çˆ¹çº¢åˆ©æœŸæ¨¡æ‹Ÿå™¨å®‰å…¨æ—¥å¿—\n
	   ç”Ÿæˆæ—¶é—´: ${timeStamp}
	   ==================== MD5 & AES ====================
	   MD5æ ‡è¯†ç¬¦: ${currentMD5}
	   AESç¼–ç : ${currentAES}
	   =================== ç‰Œå †è¯¦ç»†ä¿¡æ¯ ===================
	   æ€»ç‰Œæ•°: ${deck.length}
	   å½“å‰ç‰Œå †é¡ºåº:
	   ${deckDetails}
	   ==================== ç³»ç»Ÿä¿¡æ¯ ======================
	   ç”¨æˆ·ç³»ç»Ÿ: ${navigator.userAgent}
	   `;
			}

			function showSecurityAlert() {
				const alertBox = document.createElement('div');
				alertBox.className = 'security-alert';
				alertBox.innerHTML = `
	           <strong>å®‰å…¨æç¤º</strong>
	           <p>ç”±äºä¿éšœç”¨æˆ·ä¿¡æ¯å®‰å…¨ï¼Œè¯¥åŠŸèƒ½ä»…é™Windowsç³»ç»Ÿç”¨æˆ·ä½¿ç”¨ã€‚è¯¥åŠŸèƒ½ä¼šåœ¨æ‚¨çš„æµè§ˆå™¨ä¸­ç”Ÿæˆä¸€ä¸ªåŒ…å«æœ¬æ¬¡ç‰Œå †çš„MD5ã€AESç¼–ç åŠç‰Œå †è¯¦ç»†ä¿¡æ¯çš„txtæ–‡ä»¶ã€‚</p>
	           <p>è¯·é—®æ˜¯å¦ç»§ç»­åˆ›å»ºï¼Ÿ</p>
	           <button class="confirm">æ˜¯ï¼Œç»§ç»­åˆ›å»º</button>
	           <button class="cancel">å¦ï¼Œå–æ¶ˆæ“ä½œ</button>
	       `;
				const backdrop = document.createElement('div');
				backdrop.style = `
	           position: fixed;
	           top:0; left:0; right:0; bottom:0;
	           background: rgba(0,0,0,0.5);
	           display: flex;
	           align-items: center;
	           justify-content: center;
	           z-index: 9999;
	       `;
				backdrop.appendChild(alertBox);
				document.body.appendChild(backdrop);
				return new Promise(resolve => {
					alertBox.querySelector('.confirm').onclick = () => {
						document.body.removeChild(backdrop);
						resolve(true);
					};
					alertBox.querySelector('.cancel').onclick = () => {
						document.body.removeChild(backdrop);
						resolve(false);
					};
				});
			}
			document.getElementById('exportLog').addEventListener('click', async () => {
				if (!isWindowsOS()) {
					alert('å½“å‰åŠŸèƒ½ä»…é™Windowsç³»ç»Ÿç”¨æˆ·ä½¿ç”¨');
					return;
				}
				const userConfirm = await showSecurityAlert();
				if (!userConfirm) {
					log('ç”¨æˆ·å–æ¶ˆäº†æ—¥å¿—ç”Ÿæˆ');
					return;
				}
				try {
					const content = generateSecurityLog();
					const blob = new Blob([content], {
						type: 'text/plain;charset=utf-8'
					});
					const downloadLink = document.createElement('a');
					downloadLink.href = URL.createObjectURL(blob);
					downloadLink.download = `PileLog_${Date.now()}.txt`;
					document.body.appendChild(downloadLink);
					downloadLink.click();
					document.body.removeChild(downloadLink);
					log('å®‰å…¨æ—¥å¿—æ–‡ä»¶å·²ç”Ÿæˆ');
				} catch (error) {
					console.error('å¯¼å‡ºå¤±è´¥:', error);
					log('å®‰å…¨æ—¥å¿—ç”Ÿæˆå¤±è´¥');
				}
			});

			function log(message) {
				const logDiv = document.getElementById('log');
				const container = document.getElementById('log-container');
				const newEntry = document.createElement('p');
				newEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
				logDiv.appendChild(newEntry);
				container.scrollTop = 0;
			}
			let isCollapsed = false;
			document.getElementById('toggleCounter').addEventListener('click', () => {
				const counter = document.getElementById('remaining-counts');
				const btn = document.getElementById('toggleCounter');
				isCollapsed = !isCollapsed;
				counter.classList.toggle('collapsed');
				btn.innerHTML = isCollapsed ? 'â–¶ å±•å¼€' : 'â–¼ æ”¶èµ·';
			});

			function toggleSection(sectionId, button, isCollapsedFlag) {
				const section = document.getElementById(sectionId);
				isCollapsedFlag = !isCollapsedFlag;
				section.classList.toggle('collapsed');
				button.innerHTML = isCollapsedFlag ? 'â–¶ å±•å¼€' : 'â–¼ æ”¶èµ·';
				return isCollapsedFlag;
			}
			document.getElementById('toggleMD5AES').addEventListener('click', () => {
				isMD5AESCollapsed = toggleSection('md5aes-container',
					document.getElementById('toggleMD5AES'), isMD5AESCollapsed);
			});

			function handleKeyPress(event) {
				if (document.activeElement.tagName === 'INPUT') return;
				const reshuffleDisabled = document.getElementById('reshuffleBtn').disabled;
				const playBtnDisabled = document.getElementById('playBtn').disabled;
				const endPlayDisabled = document.getElementById('endPlayBtn').disabled;

				switch (event.key.toUpperCase()) {
					case 'Q':
						if (confirm("ç¡®å®šè¦å¼ºåˆ¶åˆ·æ–°é¡µé¢å—ï¼Ÿ")) {
							location.reload(true);
						}
						break;
					case '1':
						drawCards(1);
						break;
					case '2':
						drawCards(2);
						break;
					case '3':
						drawCards(3);
						break;
					case '4':
						drawCards(4);
						break;
					case 'W':
						revealDeck();
						break;
					case 'E':
						highlightZhugeLianNu();
						break;
					case 'R':
						initializeDeck();
						log("å¿«æ·é”®æ´—ç‰Œ");
						break;
					case 'T':
						if (!reshuffleDisabled) handleReshuffle();
						break;
					case 'A':
						if (phase === 'å‡†å¤‡') drawPhase();
						break;
					case 'S':
						if (!playBtnDisabled) playPhase();
						break;
					case 'D':
						if (!endPlayDisabled) endPlayPhase();
						break;
				}
				if ('QWEASDTR1234'.includes(event.key.toUpperCase())) {
					event.preventDefault();
				}
			}

			function getCardCategory(cardName) {
				// ä½¿ç”¨å¤–éƒ¨å®šä¹‰çš„ cardCategories
				for (const category in cardCategories) {
					if (cardCategories[category].includes(cardName)) {
						return category;
					}
				}
				return "unknown";
			}

			function showCardSelector() {
				const backdrop = document.createElement('div');
				backdrop.className = 'modal-backdrop';
				const modal = document.createElement('div');
				modal.className = 'card-selector-modal';
				modal.innerHTML = `
			    <h3>é€‰æ‹©è¦æ·»åŠ çš„å¡ç‰Œç±»å‹</h3>
			    <div id="cardButtons"></div>
			    <button onclick="this.parentElement.parentElement.remove()" 
			            style="margin-top:15px; padding:8px 20px;">
			      å…³é—­
			    </button>
			  `;
				const buttonsContainer = modal.querySelector('#cardButtons');
				const types = getAllCardTypes();
				types.forEach(type => {
					const btn = document.createElement('button');
					btn.className = 'card-button';
					btn.textContent = type;
					btn.onclick = () => {
						addSpecificCard(type);
						backdrop.remove();
					};
					buttonsContainer.appendChild(btn);
				});
				backdrop.appendChild(modal);
				document.body.appendChild(backdrop);
				backdrop.onclick = (e) => {
					if (e.target === backdrop) {
						backdrop.remove();
					}
				};
			}
			document.getElementById('testCardBtn').addEventListener('click', showCardSelector);

			function getAllCardTypes() {
				const typeSet = new Set();
				standardDeck.forEach(card => {
					if (deck.some(c => c.name === card.name)) {
						typeSet.add(card.name);
					}
				});
				return Array.from(typeSet).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
			}

			function addSpecificCard(cardName) {
				const availableCards = deck.filter(c => c.name === cardName);
				if (availableCards.length === 0) {
					alert(`ç‰Œå †ä¸­æ²¡æœ‰ã€${cardName}ã€‘ï¼`);
					log(`å°è¯•æ·»åŠ ${cardName}å¤±è´¥ï¼ˆç‰Œå †æ— æ­¤å¡ï¼‰`);
					return;
				}
				const randomBuffer = new Uint32Array(1);
				window.crypto.getRandomValues(randomBuffer);
				const selectedIndex = randomBuffer[0] % availableCards.length;
				const selectedCard = availableCards[selectedIndex];
				const deckIndex = deck.findIndex(c => c.uid === selectedCard.uid);
				if (deckIndex > -1) {
					const [removed] = deck.splice(deckIndex, 1);
					hand.push(removed);
					log(`æ‰‹åŠ¨æ·»åŠ å¡ç‰Œï¼š${removed.name} ${removed.suit}${getPointDisplay(removed.point)}`);
					updateUI();
					updateRemaining();
					generateDeckMD5();
					const feedback = document.createElement('div');
					feedback.textContent = `å·²æ·»åŠ ï¼š${removed.name}`;
					feedback.style =
						'position:fixed; top:20px; left:50%; transform:translateX(-50%); padding:10px; background:#4CAF50; color:white;';
					document.body.appendChild(feedback);
					setTimeout(() => feedback.remove(), 2000);
				}
			}

			function updateTooltipAlignment() {
				const tooltipContainers = document.querySelectorAll('.tooltip-container');
				tooltipContainers.forEach(container => {
					const button = container.querySelector('button');
					const tooltip = container.querySelector('.tooltip');
					if (button && tooltip) {
						const rect = button.getBoundingClientRect();
						const viewportWidth = window.innerWidth;
						const tooltipWidth = tooltip.offsetWidth || 350;
						const leftSpace = rect.left;
						const rightSpace = viewportWidth - rect.right;
						if (rightSpace >= tooltipWidth) {
							container.classList.remove('right-align');
						} else if (leftSpace >= tooltipWidth) {
							container.classList.add('right-align');
						} else {
							if (rightSpace > leftSpace) {
								container.classList.remove('right-align');
							} else {
								container.classList.add('right-align');
							}
						}
					}
				});
			}
			window.addEventListener('load', () => {
				setTimeout(updateTooltipAlignment, 100);
			});
			window.addEventListener('resize', updateTooltipAlignment);
			window.addEventListener('scroll', updateTooltipAlignment);
			document.querySelectorAll('.tooltip-container').forEach(container => {
				container.addEventListener('mouseenter', updateTooltipAlignment);
			});

			function initializeGame() {
				initializeDeck();
				initializeButtons();
				document.addEventListener('keydown', handleKeyPress);
				document.getElementById('testUniformBtn').style.display = isDevMode ? 'inline' : 'none';
				document.getElementById('testPerfBtn').style.display = isDevMode ? 'inline' : 'none';
			}
			document.getElementById('draw1Button').addEventListener('click', () => drawCards(1));
			document.getElementById('draw2Button').addEventListener('click', () => drawCards(2));
			document.getElementById('draw3Button').addEventListener('click', () => drawCards(3));
			document.getElementById('draw4Button').addEventListener('click', () => drawCards(4));
			document.getElementById('revealButton').addEventListener('click', revealDeck);
			document.getElementById('highlightButton').addEventListener('click', highlightZhugeLianNu);
			document.getElementById('shuffleButton').addEventListener('click', () => {
				initializeDeck();
				log("ç”¨æˆ·ç‚¹å‡»äº†é‡æ–°æ´—ç‰ŒæŒ‰é’®");
			});
			document.getElementById('reshuffleBtn').addEventListener('click', handleReshuffle);
			document.getElementById('drawBtn').addEventListener('click', drawPhase);
			document.getElementById('playBtn').addEventListener('click', playPhase);
			document.getElementById('reloadButton').addEventListener('click', () => {
				if (confirm("ç¡®å®šè¦å¼ºåˆ¶åˆ·æ–°é¡µé¢å—ï¼Ÿç½‘é¡µå°†å›åˆ°åˆå§‹é¡µé¢")) {
					location.reload(true);
				}
			});
			document.getElementById('endPlayBtn').addEventListener('click', endPlayPhase);
			document.getElementById('testUniformBtn').addEventListener('click', async () => {
				const userConfirm = await showPerformanceWarning();
				if (userConfirm) {
					console.log('å¼€å§‹æ‰§è¡Œå‡åŒ€æ€§æµ‹è¯•');
					testShuffleUniformity();
				}
			});
			document.getElementById('testPerfBtn').addEventListener('click', async () => {
				const userConfirm = await showPerformanceWarning();
				if (userConfirm) {
					console.log('å¼€å§‹æ‰§è¡Œæ€§èƒ½æµ‹è¯•');
					testShufflePerformance();
				}
			});
			initializeGame();
		</script>
		<footer class="site-footer">
			<div class="author-info">
				<p>
					ä½œè€…ï¼š <a href="https://space.bilibili.com/87412647?spm_id_from=333.1007.0.0"
						target="_blank">bilibiliæœˆãŒç¶ºéº—ã§ã™ã­_</a><br />
					è”ç³»æ–¹å¼ï¼š<a href="mailto:3099637681@qq.com" target="_blank">3099637681@qq.comï¼ˆQQåŒå·ï¼‰</a><br />
					æœ‰ä»€ä¹ˆæ–°åŠŸèƒ½æˆ–å»ºè®®æ¬¢è¿éªšæ‰°ï¼ˆè‘—åæ¥æ„ï¼‰
				</p>
			</div>
			<div class="code-update">
				<a href="https://gitee.com/a3099637681/judiehongliqi" target="_blank" class="buttoncopy"
					rel="noopener noreferrer">
					[Gitee]è·å–åç»­ä»£ç æ›´æ–°
				</a>
				<a href="https://www.bilibili.com/read/readlist/rl929858?spm_id_from=333.1387.0.0" target="_blank"
					class="bili-button" rel="noopener noreferrer">
					[bilibili]è·å–æ›´æ–°åŠ¨æ€
				</a>
				<a href="https://github.com/1145141919810TONNY/sgsmoniqi/blob/main/%E4%B8%89%E5%9B%BD%E6%9D%80%E6%A8%A1%E6%8B%9F%E5%99%A8" target="_blank" class="buttoncopy" rel="noopener noreferrer">
					[GitHub]è·å–åç»­ä»£ç æ›´æ–°
				</a>
			</div>
			<div class="license-notice">
				<p>
					Copyright &copy; <span id="copyright-year">2025</span> bilibili æœˆãŒç¶ºéº—ã§ã™ã­_<br />
					Released under the
					<a href="https://gitee.com/a3099637681/judiehongliqi/blob/master/LICENSE" title="æŸ¥çœ‹MITè®¸å¯è¯"
						class="license-link" target="_blank">
						MIT License
					</a>
				</p>
				<p class="i18n-annotation">
					(æ³•å¾‹æ¡æ¬¾ä»¥è‹±æ–‡ç‰ˆ<a href="https://gitee.com/a3099637681/judiehongliqi/blob/master/LICENSE"
						target="_blank">LICENSE</a>æ–‡ä»¶ä¸ºå‡†)
				</p>
			</div>
		</footer>
	</body>
</html>
