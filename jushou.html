<!DOCTYPE html>
<!-- 文档类型声明：指定为HTML5文档 -->
<html lang="en">
	<!-- HTML文档根元素，lang属性指定文档语言为英语 -->
	<head>
		<!-- 文档头部：包含元数据、脚本和样式表 -->
		<meta charset="UTF-8">
		<!-- 字符编码声明：指定文档使用UTF-8编码，支持多语言字符 -->
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- 视口设置：确保页面在不同设备上正确缩放和显示 -->
		<script src="js/card.js"></script>
		<!-- 引入本地JavaScript文件：包含卡牌相关逻辑 -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
		<!-- 引入CryptoJS库：提供加密功能（MD5/AES） -->
		<title>沮爹红利期模拟器</title>
		<!-- 页面标题：显示在浏览器标签页上 -->
		<link rel="stylesheet" href="css/head.css">
		<!-- 引入外部CSS文件：定义页面样式 -->
	</head>
	<body>
		<!-- 页面主体内容 -->
		<div class="header">
			<!-- 顶部操作栏容器 -->
			<p>操作台</p>
			<!-- 操作台标题 -->
			<button id="reloadButton" style="margin-left: 15px; background-color: #ff4444; color: white;">
				强制刷新（Q）
				<!-- 强制刷新按钮（快捷键Q） -->
			</button>
			<button id="draw1Button">发1张牌（1）</button>
			<!-- 发1张牌按钮（快捷键1） -->
			<button id="draw2Button">发2张牌（2）</button>
			<!-- 发2张牌按钮（快捷键2） -->
			<button id="draw3Button">发3张牌（3）</button>
			<!-- 发3张牌按钮（快捷键3） -->
			<button id="draw4Button">发4张牌（4）</button>
			<!-- 发4张牌按钮（快捷键4） -->
			<button id="revealButton">查看剩余牌堆（W）</button>
			<!-- 查看牌堆按钮（快捷键W） -->
			<button id="highlightButton">高亮诸葛连弩（E）</button>
			<!-- 高亮武器按钮（快捷键E） -->
			<button id="shuffleButton">重新洗牌（R）</button>
			<!-- 洗牌按钮（快捷键R） -->
			<button id="reshuffleBtn" disabled>使用脚气卡（T）</button>
			<!-- 脚气卡按钮（初始禁用，快捷键T） -->
			<button id="drawBtn">进入摸牌阶段（A）</button>
			<!-- 摸牌阶段按钮（快捷键A） -->
			<button id="playBtn" disabled>进入出牌阶段（S）</button>
			<!-- 出牌阶段按钮（初始禁用，快捷键S） -->
			<button id="endPlayBtn" disabled>结束出牌阶段（D）</button>
			<!-- 结束出牌按钮（初始禁用，快捷键D） -->
			<button id="testCardBtn">测试功能：添加指定牌</button>
			<!-- 测试功能按钮 -->
			<button id="testUniformBtn">洗牌均匀性测试</button>
			<!-- 洗牌测试按钮 -->
		</div>
		<div class="header-placeholder"></div>
		<!-- 占位元素：确保内容不被顶部操作栏遮挡 -->
		<section class="hero-section">
			<h1 class="hero-title">沮爹红利期模拟器纯随机版</h1>
			<!-- 主标题：显示应用名称和版本 -->
			<div class="tooltip-container">
				<!-- 导航按钮容器 -->
				<div class="nav-buttons">
					<button class="nav-button"><a href="index.html">返回主页</a></button>
					<!-- 主页导航按钮 -->
					<button class="nav-button"><a href="versionjs.html">跳转到更新日志</a></button>
					<!-- 更新日志导航按钮 -->
					<button class="nav-button"><a href="OSjushou.html">进入沮爹模拟器开源教学网页</a></button>
					<!--教学网页导航按钮-->
				</div>
			</div>

			<button id="backToTopBtn">回到顶部</button>
			<h3 class="hero-title">
				<!-- 使用说明 -->
				说明：<br />
				1.本代码的牌堆是真正的纯随机，专治各种嘴硬<br />
				<!-- 换行：强调牌堆随机性 -->
				2.请先查看剩余牌堆，再点高亮ak。<br />
				<!-- 操作提示：查看牌堆后再高亮武器 -->
				3.由于是纯随机序列，有一大堆杀闪扎堆属于正常现象（恭喜你刷到了沙摩柯的牌堆（bushi）），不想看到此类情况的，重新洗牌即可<br />
				<!-- 解释随机现象及解决方法 -->
				4.刷新按钮可在网页有不可逆的bug时将网页恢复到初始状态
				<!-- 刷新按钮的功能说明 -->
			</h3>
		</section>

		<h2>安全校验区MD5/AES编码
			<button id="toggleMD5AES" style="font-size: 12px; padding: 2px 5px;">▼ 收起</button>
			<!-- 安全区域标题和折叠按钮 -->
		</h2>
		<div id="md5aes-container">
			<!-- 加密信息容器 -->
			<div class="md5-panel">
				<!-- MD5面板 -->
				<div class="md5-display">
					<div id="md5Value">​**​*​**​*</div>
					<!-- MD5值显示区域（初始隐藏） -->
					<div class="md5-buttons">
						<button id="toggleMD5" class="md5-button">显示MD5</button>
						<!-- 切换MD5显示状态的按钮 -->
						<button id="copyMD5" class="md5-button">复制</button>
						<!-- 复制MD5的按钮 -->
					</div>
				</div>
				<p class="md5-caption">该标识符基于当前牌堆生成，用于验证牌堆唯一性</p>
				<!-- MD5功能说明 -->
				<div class="verify-panel">
					<!-- 验证面板 -->
					<input type="text" id="verifyMD5" placeholder="输入MD5验证牌堆" class="verify-input">
					<!-- MD5输入框 -->
					<button onclick="verifyDeck()" class="md5-button">验证</button>
					<!-- 触发验证的按钮 -->
					<span id="verifyResult" class="verify-result"></span>
					<!-- 验证结果显示区域 -->
				</div>
			</div>
			<div class="aes-panel">
				<!-- AES面板 -->
				<div class="md5-display">
					<div id="aesValue" class="aes-value">​**​*​**​*</div>
					<!-- AES值显示区域（初始隐藏） -->
					<div class="md5-buttons">
						<button id="toggleAES" class="md5-button">显示AES</button>
						<!-- 切换AES显示状态的按钮 -->
						<button id="copyAES" class="md5-button">复制</button>
						<!-- 复制AES的按钮 -->
					</div>
				</div>
				<p class="aes-caption">包含密钥的AES编码，可反向解析牌堆</p>
				<!-- AES功能说明 -->
				<div class="verify-panel">
					<!-- 验证面板 -->
					<input type="text" id="verifyAES" placeholder="输入AES编码验证牌堆" class="verify-input">
					<!-- AES输入框 -->
					<button onclick="verifyAESDeck()" class="md5-button">解密验证</button>
					<!-- 触发验证的按钮 -->
					<span id="verifyAESResult" class="verify-result"></span>
					<!-- 验证结果显示区域 -->
				</div>
				<div class="log-panel">
					<button id="exportLog" class="md5-button log-button">
						📄 生成安全日志文件
						<!-- 日志导出按钮 -->
					</button>
				</div>
			</div>
		</div>
		<h2>记牌器
			<button id="toggleCounter" style="font-size: 12px; padding: 2px 5px;">▼ 收起</button>
			<!-- 记牌器标题和折叠按钮 -->
		</h2>
		<div id="remaining-counts"></div>
		<!-- 记牌器内容区域（动态生成） -->
		<h3>状态信息</h3>
		<!-- 状态信息标题 -->
		<div id="status-area">
			<!-- 状态信息容器 -->
			<div id="kill-counter">杀可用次数：2</div>
			<!-- 杀牌计数显示 -->
			<div id="zhuge-status">诸葛连弩：未装备</div>
			<!-- 武器状态显示 -->
			<div id="peach-counter">桃可用次数：1</div>
			<!-- 桃牌计数显示 -->
			<div id="wine-counter">酒可用次数：1</div>
			<!-- 酒牌计数显示 -->
			<div id="delay-area">
				<div class="delay-section">
					<h4>兵粮寸断</h4>
					<div id="bingliang-container" class="delay-cards"></div>
				</div>
				<div class="delay-section">
					<h4>乐不思蜀</h4>
					<div id="lebu-container" class="delay-cards"></div>
				</div>
				<div class="delay-section">
				    <h4>闪电</h4>
				    <div id="shandian-container" class="delay-cards"></div>
				</div>
			</div>
		</div>
		<div id="testProgress" style="display:none;">
			<!-- 测试进度条（默认隐藏） -->
			<progress value="0" max="100"></progress>
			<!-- HTML5进度条元素 -->
			<span>0%</span>
			<!-- 进度百分比显示 -->
		</div>
		<div id="deck"></div>
		<!-- 牌堆显示区域 -->
		<div id="remaining"></div>
		<!-- 剩余牌堆显示区域 -->
		<div id="hand"></div>
		<!-- 玩家手牌显示区域 -->
		<h3>操作日志</h3>
		<!-- 日志区域标题 -->
		<div id="log-container">
			<!-- 日志容器 -->
			<div id="log"></div>
			<!-- 日志内容区域（动态填充） -->
		</div>
		<div id="stageInfo" class="phase"></div>
		<!-- 游戏阶段信息显示区域 -->
		<script>
			// 定义游戏状态变量
			let deck = []; // 存储当前牌堆的数组
			let drawnCards = []; // 存储已抽取卡牌的数组
			let discardPile = []; // 存储弃牌堆的数组
			let hand = []; // 存储玩家手牌的数组
			let phase = ''; // 当前游戏阶段（准备/摸牌/出牌）
			let lastUsedCard = null; // 上一次使用的卡牌对象
			let reshuffleUsed = 0; // 脚气卡使用次数计数器
			const MAX_RESHUFLE = 7; // 脚气卡最大使用次数限制
			let currentMD5 = ''; // 当前牌堆的MD5哈希值
			let showMD5 = false; // 控制MD5值是否显示的标志
			let currentAES = ''; // 当前牌堆的AES加密值
			let showAES = false; // 控制AES值是否显示的标志
			let originalDeck = []; // 原始牌堆备份（未使用）
			let isCounterCollapsed = false; // 记牌器是否折叠的标志
			let isMD5AESCollapsed = false; // 安全校验区是否折叠的标志
			let killCount = 2; // 可用的"杀"次数
			let hasZhugeLianNu = false; // 是否装备诸葛连弩的标志
			let currentWeapon = null; // 当前装备的武器
			let peachCount = 1; // 可用的"桃"次数
			let wineCount = 1; // 可用的"酒"次数

			let bingliangArea = []; // 兵粮寸断存放区
			let lebuArea = []; // 乐不思蜀存放区
			const MAX_DELAY_CARDS = 2; // 每种牌上限2张
			
			let shandianArea = []; // 闪电存放区
			const MAX_SHANDIAN = 1; // 闪电上限1张

			// 初始化牌堆函数
			function initializeDeck() {
				// 清空操作日志
				document.getElementById('log').innerHTML = '';
				log("牌堆初始化开始");

				// 重置所有牌堆相关变量
				deck = [];
				drawnCards = [];
				discardPile = [];
				hand = [];
				document.getElementById('deck').innerHTML = ''; // 清空牌堆显示区域
				reshuffleUsed = 0; // 重置脚气卡使用次数
				phase = ''; // 重置游戏阶段
				lastUsedCard = null; // 重置最后使用的卡牌
				peachCount = 1; // 重置桃使用次数
				wineCount = 1; // 重置酒使用次数
				
				// 重置延时锦囊区
				    bingliangArea = [];
				    lebuArea = [];

				// 使用外部定义的standardDeck（在card.js中）创建牌堆
				standardDeck.forEach(card => {
					// 处理每张卡牌的花色和点数
					card.suits.forEach(suitStr => {
						// 使用正则表达式解析花色和点数
						const match = suitStr.match(/^([♠♥♣♦]️?)([JQKA]|\d+)$/);
						if (match) {
							const suitPart = match[1]; // 提取花色部分
							let point = match[2]; // 提取点数部分

							// 将字母点数转换为数字
							switch (point) {
								case 'J':
									point = 11;
									break;
								case 'Q':
									point = 12;
									break;
								case 'K':
									point = 13;
									break;
								case 'A':
									point = 1;
									break;
								default:
									point = parseInt(point, 10); // 数字点数直接转换为整数
							}

							// 根据卡牌数量创建多个副本
							for (let i = 0; i < card.count; i++) {
								// 创建卡牌对象并添加到牌堆
								deck.push({
									name: card.name, // 卡牌名称
									suit: suitPart, // 花色
									point: point, // 点数
									uid: CryptoJS.lib.WordArray.random(16).toString() // 唯一ID
								});
							}
						}
					});
				});

				// 重置武器和攻击状态
				currentWeapon = null;
				killCount = 2;
				hasZhugeLianNu = false;

				// 重置延时锦囊区
				bingliangArea = [];
				lebuArea = [];
				shandianArea = [];

				// 更新状态显示
				updateStatus();
				// 洗牌
				shuffleDeck();
				// 生成牌堆MD5
				generateDeckMD5();
				// 更新MD5显示
				updateMD5Display();
				// 生成牌堆AES
				generateDeckAES();
				// 更新AES显示
				updateAESDisplay();
				// 更新剩余牌数显示
				updateRemaining();
				// 开始游戏
				startGame();
				log("牌堆初始化完成");
			}

			// 将卡牌点数转换为显示格式的函数
			function getPointDisplay(point) {
				switch (point) {
					case 11:
						return 'J'; // 11点显示为J
					case 12:
						return 'Q'; // 12点显示为Q
					case 13:
						return 'K'; // 13点显示为K
					case 1:
						return 'A'; // 1点显示为A
					default:
						return point; // 其他点数直接显示数字
				}
			}

			// 生成牌堆的MD5哈希值
			function generateDeckMD5() {
				// 将牌堆按卡牌UID排序，确保顺序一致
				const deckString = deck
					.sort((a, b) => a.uid.localeCompare(b.uid))
					// 将每张卡牌转换为字符串格式：名称|花色|点数|UID
					.map(c => `${c.name}|${c.suit}|${c.point}|${c.uid}`)
					// 用"@@"连接所有卡牌字符串
					.join('@@');

				// 生成牌堆字符串的MD5哈希（第一次哈希）
				const firstHash = CryptoJS.MD5(deckString).toString();

				// 获取当前时间戳并转换为16进制字符串（填充到16位）
				const timestamp = Date.now().toString(16).padStart(16, '0');

				// 将第一次哈希结果与时间戳结合，生成最终的MD5值
				currentMD5 = CryptoJS.MD5(firstHash + timestamp).toString();

				// 检查URL参数中是否有debug标志
				const isDebug = new URLSearchParams(window.location.search).has('debug');

				// 调试模式下使用原始哈希（不含时间戳），否则使用带时间戳的哈希
				currentMD5 = isDebug ? firstHash : CryptoJS.MD5(firstHash + timestamp).toString();

				// 在调试模式下输出原始哈希值
				if (isDebug) console.log("调试模式MD5（不含时间戳）:", currentMD5);
			}

			// 存储牌堆快照的对象
			const deckSnapshots = {};

			// 保存当前牌堆快照
			function saveSnapshot() {
				// 创建牌堆快照对象
				const snapshot = {
					deck: deck.map(c => ({
						...c
					})), // 创建牌堆的深拷贝
					md5: currentMD5, // 当前MD5值
					timestamp: Date.now() // 当前时间戳
				};

				// 以MD5为键存储快照
				deckSnapshots[currentMD5] = snapshot;

				// 将快照保存到本地存储
				localStorage.setItem('md5Snapshots', JSON.stringify(deckSnapshots));

				// 记录日志
				log(`牌堆快照已保存 (MD5: ${currentMD5})`);
			}

			// 加载指定MD5对应的牌堆快照
			function loadSnapshot(targetMD5) {
				// 获取对应MD5的快照
				const snapshot = deckSnapshots[targetMD5];

				// 如果没有找到快照则提示用户
				if (!snapshot) return alert("无此牌堆记录");

				// 恢复牌堆状态
				deck = snapshot.deck;
				currentMD5 = snapshot.md5;

				// 更新用户界面
				updateUI();

				// 记录日志
				log(`已加载牌堆快照 (MD5: ${targetMD5})`);
			}

			// 更新MD5值的显示
			function updateMD5Display() {
				const display = document.getElementById('md5Value');
				if (showMD5) {
					// 格式化MD5值：每4个字符加一个连字符
					const formatted = currentMD5
						.match(/.{1,4}/g) // 将字符串分割为每4个字符一组
						.join('-') // 用连字符连接各组
						.toUpperCase(); // 转换为大写

					// 显示格式化后的MD5值
					display.textContent = formatted;
					display.style.color = '#2196F3'; // 设置蓝色文本
				} else {
					// 隐藏MD5值，显示星号
					display.textContent = '​**​*​**​*';
					display.style.color = '#666'; // 设置灰色文本
				}
			}

			// 为"显示/隐藏MD5"按钮添加点击事件
			document.getElementById('toggleMD5').addEventListener('click', () => {
				// 切换显示状态
				showMD5 = !showMD5;

				// 更新按钮文本
				document.getElementById('toggleMD5').textContent =
					showMD5 ? '隐藏MD5' : '显示MD5';

				// 更新显示内容
				updateMD5Display();
			});

			// 为"复制MD5"按钮添加点击事件
			document.getElementById('copyMD5').addEventListener('click', () => {
				// 如果没有MD5值则直接返回
				if (!currentMD5) return;

				// 定义复制函数
				const copy = async () => {
					try {
						// 尝试使用现代剪贴板API
						await navigator.clipboard.writeText(currentMD5);

						// 添加复制成功的视觉反馈
						document.getElementById('copyMD5').classList.add('copied');

						// 1秒后移除视觉反馈
						setTimeout(() => {
							document.getElementById('copyMD5').classList.remove('copied');
						}, 1000);

						// 记录日志
						log('MD5已复制到剪贴板');
					} catch (err) {
						// 现代API失败时使用传统方法
						const textarea = document.createElement('textarea');
						textarea.value = currentMD5;
						document.body.appendChild(textarea);
						textarea.select();
						document.execCommand('copy');
						document.body.removeChild(textarea);
						log('MD5已复制（传统方式）');
					}
				};

				// 执行复制并处理可能的错误
				copy().catch(err => {
					console.error('复制失败:', err);
					log('复制失败，请手动选择复制');
				});
			});

			// 验证用户输入的MD5值
			function verifyDeck() {
				// 获取用户输入的MD5值并清理格式
				const inputMD5 = document.getElementById('verifyMD5').value
					.replace(/-/g, '') // 移除连字符
					.toLowerCase(); // 转换为小写

				// 与当前MD5比较
				const isValid = currentMD5 === inputMD5;

				// 获取结果显示元素
				const resultSpan = document.getElementById('verifyResult');

				// 设置验证结果文本和颜色
				resultSpan.textContent = isValid ? '✅ 验证通过' : '❌ 验证失败';
				resultSpan.style.color = isValid ? '#4CAF50' : '#f44336'; // 绿色/红色

				// 记录日志
				log(`牌堆MD5验证${isValid ? '成功' : '失败'}`);
			}

			// 生成牌堆的AES加密表示
			function generateDeckAES() {
				try {
					// 简化牌堆数据结构（减少JSON大小）
					const deckData = deck.map(c => ({
						n: c.name, // 卡牌名称（缩写）
						s: c.suit, // 花色
						p: c.point, // 点数
						u: c.uid // 唯一ID（缩写）
					}));

					// 生成随机密钥（128位）
					const key = CryptoJS.lib.WordArray.random(128 / 8);

					// 生成随机初始化向量（128位）
					const iv = CryptoJS.lib.WordArray.random(128 / 8);

					// 使用AES-CBC模式加密牌堆数据
					const encrypted = CryptoJS.AES.encrypt(
						JSON.stringify(deckData), // 要加密的字符串化牌堆数据
						key, // 加密密钥
						{
							iv: iv
						} // 初始化向量
					);

					// 构建AES编码：密钥::初始化向量::加密数据
					currentAES = [
						key.toString(CryptoJS.enc.Base64), // Base64编码的密钥
						iv.toString(CryptoJS.enc.Base64), // Base64编码的初始化向量
						encrypted.toString() // 加密后的字符串
					].join('::');
				} catch (e) {
					// 错误处理：输出错误并设置错误标识
					console.error('AES生成失败:', e);
					currentAES = 'ERROR';
				}
			}

			// 更新AES值的显示
			function updateAESDisplay() {
				const display = document.getElementById('aesValue');
				if (!display) return; // 安全检查：确保元素存在

				if (showAES) {
					// 格式化显示：每24个字符换行
					const formatted = currentAES
						.match(/.{1,24}/g) // 将字符串分割成最多24字符的片段
						.join('\n'); // 用换行符连接

					// 显示格式化后的AES值
					display.textContent = formatted;
					display.style.color = '#2196F3'; // 设置蓝色文本
				} else {
					// 隐藏AES值，显示星号
					display.textContent = '​**​*​**​*';
					display.style.color = '#666'; // 设置灰色文本
				}
			}

			// 为"显示/隐藏AES"按钮添加点击事件
			document.getElementById('toggleAES').addEventListener('click', () => {
				// 切换显示状态
				showAES = !showAES;

				// 更新按钮文本
				document.getElementById('toggleAES').textContent =
					showAES ? '隐藏AES' : '显示AES';

				// 更新显示内容
				updateAESDisplay();
			});

			// 为"复制AES"按钮添加点击事件
			document.getElementById('copyAES').addEventListener('click', () => {
				// 检查AES值是否有效
				if (!currentAES || currentAES === '​**​*​**​*') return;

				// 定义复制函数
				const copy = async () => {
					try {
						// 尝试使用现代剪贴板API
						await navigator.clipboard.writeText(currentAES);

						// 添加复制成功的视觉反馈
						document.getElementById('copyAES').classList.add('copied');

						// 1秒后移除视觉反馈
						setTimeout(() => {
							document.getElementById('copyAES').classList.remove('copied');
						}, 1000);

						// 记录日志
						log('AES编码已复制');
					} catch (err) {
						// 现代API失败时使用传统方法
						const textarea = document.createElement('textarea');
						textarea.value = currentAES;
						document.body.appendChild(textarea);
						textarea.select();
						document.execCommand('copy');
						document.body.removeChild(textarea);
						log('AES编码已复制（传统方式）');
					}
				};

				// 执行复制并处理可能的错误
				copy().catch(err => {
					console.error('复制失败:', err);
					log('AES复制失败，请手动选择复制');
				});
			});

			// 验证并解密用户输入的AES编码
			function verifyAESDeck() {
				// 获取用户输入的AES编码
				const input = document.getElementById('verifyAES').value.trim();
				const resultSpan = document.getElementById('verifyAESResult');

				// 检查输入是否为空
				if (!input) {
					resultSpan.textContent = '❌ 请输入编码';
					resultSpan.style.color = '#f44336'; // 红色错误提示
					return;
				}

				try {
					// 分割输入：格式应为 密钥::初始化向量::加密数据
					const [keyB64, ivB64, data] = input.split('::');

					// 验证格式是否正确
					if (!keyB64 || !ivB64 || !data) throw new Error('格式无效');

					// 从Base64解析密钥和初始化向量
					const key = CryptoJS.enc.Base64.parse(keyB64);
					const iv = CryptoJS.enc.Base64.parse(ivB64);

					// 使用AES解密数据
					const decrypted = CryptoJS.AES.decrypt(data, key, {
						iv: iv
					});

					// 将解密结果转换为UTF-8字符串
					const utf8String = decrypted.toString(CryptoJS.enc.Utf8);

					// 检查解密是否成功
					if (!utf8String) throw new Error('解密失败');

					// 解析解密后的JSON数据
					const decoded = JSON.parse(utf8String);

					// 重建牌堆数据结构
					deck = decoded.map(c => ({
						name: c.n, // 恢复卡牌名称
						suit: c.s, // 恢复花色
						point: c.p, // 恢复点数
						uid: c.u // 恢复唯一ID
					}));

					// 更新相关状态和显示
					generateDeckMD5(); // 重新生成MD5
					updateMD5Display(); // 更新MD5显示
					updateRemaining(); // 更新剩余牌数
					revealDeck(); // 显示牌堆

					// 记录日志
					log('AES解码成功，牌堆已加载');

					// 显示验证成功
					resultSpan.textContent = '✅ 验证通过';
					resultSpan.style.color = '#4CAF50'; // 绿色成功提示
				} catch (e) {
					// 错误处理
					console.error('AES验证失败:', e);
					resultSpan.textContent = '❌ 无效编码';
					resultSpan.style.color = '#f44336'; // 红色错误提示
					log('AES解码失败: ' + e.message);
				}
			}
			// 生成安全的随机索引（用于抽牌）
			function getSecureRandomIndex(max) {
				// 检查浏览器是否支持加密安全的随机数生成器
				if (window.crypto && typeof window.crypto.getRandomValues === 'function') {
					// 创建一个Uint32Array来存储随机值
					const randomBuffer = new Uint32Array(1);

					// 使用加密安全方法填充随机值
					window.crypto.getRandomValues(randomBuffer);

					// 返回0到max之间的随机索引
					return randomBuffer[0] % (max + 1);
				} else {
					// 浏览器不支持安全随机数时使用Math.random
					return Math.floor(Math.random() * (max + 1));
				}
			}

			// 执行洗牌均匀性测试
			async function testShuffleUniformity() {
				// 测试配置
				const CONFIG = {
					TOTAL_TRIALS: 100000, // 总测试次数
					BATCH_SIZE: 5000, // 每批测试次数
					DECK_SIZE: 160, // 牌堆大小
					AK_COUNT: 2, // 诸葛连弩(AK)数量
					CHECK_SIZE: 7 // 检查前几张牌
				};

				// 创建模态背景
				const backdrop = document.createElement('div');
				backdrop.style.cssText = `
					position: fixed;
					top: 0;
					left: 0;
					right: 0;
					bottom: 0;
					background: rgba(0,0,0,0.5);
					z-index: 9998;
					backdrop-filter: blur(3px);
				`;

				// 创建测试面板
				const panel = document.createElement('div');
				panel.className = 'scrollable-panel';
				panel.style.cssText = `
					position: fixed;
					top: 50%;
					left: 50%;
					transform: translate(-50%, -50%);
					background: white;
					padding: 25px;
					border-radius: 12px;
					box-shadow: 0 4px 20px rgba(0,0,0,0.25);
					z-index: 9999;
					width: 80%;
					max-width: 800px;
					max-height: 90vh;
					overflow-y: auto;
					font-family: Arial, sans-serif;
				`;

				// 面板内容HTML
				panel.innerHTML = `
					<div style="position: relative; margin-bottom: 20px;">
						<h2 style="margin:0 0 10px; color:#333; font-size:20px;">洗牌均匀性测试</h2>
						<div style="position: absolute; top: -15px; right: -15px; display: flex; gap: 5px;">
							<button id="rerunTest" style="padding: 8px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">
								重新测试 ▶
							</button>
							<button id="closePanel" style="padding: 8px 20px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">
								关闭窗口 ×
							</button>
						</div>
					</div>
					<div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-bottom:15px;">
						<div>
							<h3 style="font-size:14px; color:#666; margin:0 0 8px;">实际结果</h3>
							<p>≥1张AK： <span id="actualSingle">0</span></p>
							<p>≥2张AK： <span id="actualDouble">0</span></p>
						</div>
						<div>
							<h3 style="font-size:14px; color:#666; margin:0 0 8px;">理论参考</h3>
							<p>≈8.51% (单AK)</p>
							<p>≈0.165% (双AK)</p>
						</div>
					</div>
					<div style="margin-top:20px; padding:15px; background:#f8f9fa; border-radius:6px;">
						<!-- 单AK计算公式 -->
						<div style="margin-bottom:25px;">
							<h4 style="color:#444; margin:0 0 8px; font-size:14px;">1. 至少1张诸葛连弩（≈8.56%）</h4>
							<div style="font-family:monospace; font-size:14px;">
								<p style="margin:6px 0">N=160（总牌数）</p>
								<p style="margin:6px 0">K=2（诸葛连弩数量）</p>
								<p style="margin:6px 0">n=7（抽牌数）</p>
								<p style="margin:4px 0;">P(≥1) = 1 - [C(158,7) / C(160,7)]</p>
								<p style="margin:4px 0; color:#666;">      = 1 - 158！/ （7！* 151！）/ 160！/（7！ 8 153！）</p>
								<p style="margin:4px 0; color:#666;">      = 1 - (158×157) / (160×159)</p>
								<p style="margin:4px 0; color:#2196F3;">      ≈ 8.51%</p>
							</div>
						</div>
						<!-- 双AK计算公式 -->
						<div style="margin-bottom:25px;">
							<h4 style="color:#444; margin:0 0 8px; font-size:14px;">2. 至少2张诸葛连弩（≈0.165%）</h4>
							<div style="font-family:monospace; font-size:14px;">
								<div style="margin-bottom:8px;">
									<p style="margin:4px 0;">计算公式</p>
									<p style="margin:4px 0;">P (≥2) = C ( K , 2 ) * C( N - K , n - 2) / C(N , n)</p>
									<p style="margin:4px 0;">P (=2) = C ( 2 , 2 ) * C( 158 , 5 ) / C (160 , 7)</P>
									<p style="margin:4px 0;">       = (1 * 158! / 5! * 153! ) / 160! / 7! * 153!</p>
									<p style="margin:4px 0;">P(≥2) = [C(2,2)·C(158,5)] / C(160,7)</p>
									<p style="margin:4px 0; color:#666;">      = [1 × (158×157×156×155×154)]</p>
									<p style="margin:4px 0; color:#666;">      / [160×159×158×157×156×155×154]</p>
								</div>
								<div style="border-left:3px solid #ddd; padding-left:12px; color:#666;">
									<p style="margin:4px 0;">分子化简：7×6=42</p>
									<p style="margin:4px 0;">分母化简：160×159=25,440</p>
									<p style="margin:4px 0; color:#2196F3;">最终≈42/25,440≈0.165%</p>
								</div>
							</div>
						</div>
					</div>
					<progress value="0" max="${CONFIG.TOTAL_TRIALS}" style="width:100%; height:8px; margin:15px 0;"></progress>
					<div id="akStats" style="color:#666; font-size:14px;"></div>
				`;

				// 添加面板到文档
				document.body.appendChild(backdrop);
				document.body.appendChild(panel);

				// 添加滚动条样式
				panel.style.cssText += `
					::-webkit-scrollbar { width: 12px; }
					::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
					::-webkit-scrollbar-thumb { background: #4CAF50; border-radius: 10px; }
					::-webkit-scrollbar-thumb:hover { background: #3e8e41; }
				`;

				// 初始化测试状态变量
				let isClosing = false;
				let stats = {
					single: 0,
					double: 0
				};
				let completed = 0;

				// 关闭面板函数
				const closePanel = () => {
					if (isClosing) return;
					isClosing = true;

					// 添加淡出动画
					panel.style.transition = 'opacity 0.3s, transform 0.3s';
					panel.style.opacity = '0';
					panel.style.transform = 'translate(-50%, -50%) scale(0.9)';

					backdrop.style.transition = 'opacity 0.3s';
					backdrop.style.opacity = '0';

					// 延迟移除元素
					setTimeout(() => {
						document.body.removeChild(backdrop);
						document.body.removeChild(panel);
					}, 300);
				};

				// 添加关闭和重新测试按钮事件
				panel.querySelector('#closePanel').addEventListener('click', closePanel);
				panel.querySelector('#rerunTest').addEventListener('click', () => {
					closePanel();
					testShuffleUniformity();
				});

				// 生成测试牌堆（包含AK标记）
				const generateTestDeck = () =>
					Array.from({
						length: CONFIG.DECK_SIZE
					}, (_, i) => ({
						isAK: i < CONFIG.AK_COUNT, // 前两张牌标记为AK
						id: i // 唯一标识符
					}));

				// 运行一批测试
				const runBatch = async () => {
					for (let i = 0; i < CONFIG.BATCH_SIZE; i++) {
						if (isClosing) return;

						// 生成测试牌堆
						const deck = generateTestDeck();

						// Fisher-Yates洗牌算法
						for (let j = deck.length - 1; j > 0; j--) {
							const k = Math.floor(Math.random() * (j + 1));
							[deck[j], deck[k]] = [deck[k], deck[j]];
						}

						// 检查前CHECK_SIZE张牌中AK的数量
						const akCount = deck.slice(0, CONFIG.CHECK_SIZE)
							.filter(c => c.isAK).length;

						// 更新统计
						if (akCount >= 1) stats.single++;
						if (akCount >= 2) stats.double++;
					}

					// 更新完成数量
					completed += CONFIG.BATCH_SIZE;

					// 更新进度条
					panel.querySelector('progress').value = completed;

					// 更新统计显示
					panel.querySelector('#actualSingle').textContent =
						`${stats.single} (${(stats.single / completed * 100).toFixed(2)}%)`;
					panel.querySelector('#actualDouble').textContent =
						`${stats.double} (${(stats.double / completed * 100).toFixed(2)}%)`;

					// 更新统计面板
					panel.querySelector('#akStats').innerHTML = `
						<p>已测试：${completed.toLocaleString()} 次</p>
						<p>单AK概率：${(stats.single / completed * 100).toFixed(2)}%</p>
						<p>双AK概率：${(stats.double / completed * 100).toFixed(2)}%</p>
					`;
				};

				try {
					// 记录开始时间
					const startTime = performance.now();

					// 运行测试直到完成或关闭
					while (completed < CONFIG.TOTAL_TRIALS && !isClosing) {
						await new Promise(resolve =>
							requestAnimationFrame(async () => {
								await runBatch();
								resolve();
							})
						);
					}

					// 测试完成且面板未关闭
					if (!isClosing) {
						// 计算总耗时
						const totalTime = ((performance.now() - startTime) / 1000).toFixed(1);

						// 添加最终统计
						panel.querySelector('#akStats').innerHTML += `
							<div style="margin-top:15px; padding-top:15px; border-top:1px solid #eee;">
								<p>总耗时：${totalTime} 秒</p>
								<p>测试牌堆：${CONFIG.DECK_SIZE}张（含${CONFIG.AK_COUNT}AK）</p>
							</div>
						`;
					}
				} catch (error) {
					// 错误处理
					console.error('测试出错:', error);
					panel.querySelector('#akStats').innerHTML = `
						<div style="color: red;">
							<h3>测试失败</h3>
							<p>${error.message}</p>
						</div>
					`;
				}
			}


			// 显示性能警告弹窗
			function showPerformanceWarning() {
				// 返回一个Promise，用于处理用户选择
				return new Promise((resolve) => {
					// 创建模态背景
					const backdrop = document.createElement('div');
					backdrop.style.cssText = `
						position: fixed;
						top: 0;
						left: 0;
						right: 0;
						bottom: 0;
						background: rgba(0,0,0,0.6);
						z-index: 9999;
						display: flex;
						justify-content: center;
						align-items: center;
					`;

					// 创建警告弹窗
					const alertBox = document.createElement('div');
					alertBox.style.cssText = `
						background: white;
						padding: 25px;
						border-radius: 12px;
						min-width: 400px;
						max-width: 90vw;
						box-shadow: 0 4px 20px rgba(0,0,0,0.25);
					`;

					// 弹窗内容
					alertBox.innerHTML = `
						<h2 style="margin:0 0 15px; font-size:20px; color:#d32f2f;">⚠️ 性能警告</h2>
						<ul style="margin:0 0 20px; padding-left:20px;">
							<li style="margin-bottom:8px;">CPU使用率可能达到100%</li>
							<li style="margin-bottom:8px;">浏览器可能暂时无响应（约10-30秒）</li>
							<li style="margin-bottom:8px;">移动设备可能出现明显发热</li>
						</ul>
						<div style="display: flex; gap:10px;">
							<button id="confirmBtn" 
								style="flex:1; padding:12px; background:#4CAF50; 
									   color:white; border:none; border-radius:6px;
									   cursor:pointer;">继续执行</button>
							<button id="cancelBtn"
								style="flex:1; padding:12px; background:#f44336;
									   color:white; border:none; border-radius:6px;
									   cursor:pointer;">取消操作</button>
						</div>
					`;

					// 关闭弹窗并返回结果
					const close = (result) => {
						document.body.removeChild(backdrop);
						resolve(result);
					};

					// 绑定按钮事件
					alertBox.querySelector('#confirmBtn').addEventListener('click', () => close(true));
					alertBox.querySelector('#cancelBtn').addEventListener('click', () => close(false));

					// 点击背景关闭（相当于取消）
					backdrop.addEventListener('click', (e) => {
						if (e.target === backdrop) close(false);
					});

					// 添加元素到DOM
					backdrop.appendChild(alertBox);
					document.body.appendChild(backdrop);
				});
			}

			// 构建AK统计结果的HTML字符串
			function buildAKStats(total, single, double, totalAK) {
				// 计算单AK和双AK的概率
				const singleRate = (single / total * 100).toFixed(2);
				const doubleRate = (double / total * 100).toFixed(2);

				// 返回格式化后的统计信息HTML
				return `
					<div style="border-top:1px solid #ddd; padding-top:10px;">
						<h4>诸葛连弩统计（牌堆共${totalAK}张）</h4>
						<p>前7张出现至少1张： 
							${single.toLocaleString()}/${total.toLocaleString()}, 
							${singleRate}%</p>
						<p>前7张同时出现2张： 
							${double.toLocaleString()}/${total.toLocaleString()}, 
							${doubleRate}%</p>
					</div>
				`;
			}

			// 更新AK统计显示
			function updateAKStats(progress, completed, single, double) {
				// 获取统计显示区域
				const statsDiv = progress.querySelector('#akStats');
				if (!statsDiv) return;

				// 格式化数字（千位分隔符）
				const current = completed.toLocaleString();

				// 计算当前概率
				const singleRate = (single / completed * 100).toFixed(2);
				const doubleRate = (double / completed * 100).toFixed(2);

				// 更新统计显示内容
				statsDiv.innerHTML = `
					<p>实时统计（已测试${current}次）:</p>
					<p>单AK出现率: ${singleRate}%</p>
					<p>双AK出现率: ${doubleRate}%</p>
				`;
			}

			// 生成标准牌堆
			function generateStandardDeck() {
				const deck = []; // 创建空牌堆数组

				// 遍历外部定义的standardDeck数组
				standardDeck.forEach(card => {
					// 遍历每张卡牌的花色字符串
					card.suits.forEach(suitStr => {
						// 使用正则表达式解析花色和点数
						const match = suitStr.match(/^([♠♥♣♦]️?)([JQKA]|\d+)$/);
						if (match) {
							const suitPart = match[1]; // 提取花色部分
							let point = match[2]; // 提取点数部分

							// 将字母点数转换为数字
							switch (point) {
								case 'J':
									point = 11;
									break;
								case 'Q':
									point = 12;
									break;
								case 'K':
									point = 13;
									break;
								case 'A':
									point = 1;
									break;
								default:
									point = parseInt(point, 10); // 数字直接转换
							}

							// 根据卡牌数量创建多个副本
							for (let i = 0; i < card.count; i++) {
								// 添加卡牌对象到牌堆
								deck.push({
									name: card.name, // 卡牌名称
									suit: suitPart, // 花色
									point: point, // 点数（数字）
									uid: CryptoJS.lib.WordArray.random(16).toString() // 唯一ID
								});
							}
						}
					});
				});

				return deck; // 返回生成的牌堆
			}

			// 显示性能警告弹窗（改进版）
			async function showPerformanceWarning(testFunction) {
				// 返回Promise以处理用户选择
				return new Promise((resolve) => {
					// 创建警告弹窗
					const alertBox = document.createElement('div');
					alertBox.className = 'security-alert';
					alertBox.innerHTML = `
						<strong>性能警告</strong>
						<p>即将执行压力测试，可能会造成：（系统会自动进行十万次洗牌！！！）</p>
						<ul>
							<li>▸ CPU使用率短暂飙升</li>
							<li>▸ 浏览器暂时无响应（约10-30秒）</li>
							<li>▸ 移动设备可能出现明显发热</li>
						</ul>
						<p>建议关闭其他标签页后继续，是否确认执行？</p>
						<button class="confirm">继续执行</button>
						<button class="cancel">取消操作</button>
					`;

					// 创建模态背景
					const backdrop = document.createElement('div');
					backdrop.className = 'modal-backdrop';

					// 创建容器居中弹窗
					const container = document.createElement('div');
					container.style.cssText = `
						position: fixed;
						top: 0;
						left: 0;
						width: 100%;
						height: 100%;
						display: flex;
						justify-content: center;
						align-items: center;
					`;

					// 组装元素
					container.appendChild(alertBox);
					backdrop.appendChild(container);
					document.body.appendChild(backdrop);

					// 处理用户选择
					const handler = (result) => {
						document.body.removeChild(backdrop); // 移除弹窗
						resolve(result); // 返回用户选择
					};

					// 绑定按钮事件
					alertBox.querySelector('.confirm').addEventListener('click', () => handler(true));
					alertBox.querySelector('.cancel').addEventListener('click', () => handler(false));

					// 点击背景关闭（相当于取消）
					backdrop.addEventListener('click', (e) => {
						if (e.target === backdrop) handler(false);
					});
				});
			}

			// 更新剩余卡牌计数显示
			function updateRemainingCounts() {
				// 定义卡牌分类结构
				const categories = {
					basic: {
						name: "基本牌",
						items: {}
					},
					trick: {
						name: "普通锦囊牌",
						items: {}
					},
					ystrick: {
						name: "延时锦囊牌",
						items: {}
					},
					weapon: {
						name: "武器",
						items: {}
					},
					armor: {
						name: "防具",
						items: {}
					},
					horse: {
						name: "坐骑",
						items: {}
					}
				};

				// 遍历牌堆中的所有卡牌
				deck.forEach(card => {
					// 使用外部定义的cardCategories进行分类
					for (const [type, items] of Object.entries(cardCategories)) {
						// 检查当前卡牌是否属于此分类
						if (items.includes(card.name)) {
							// 初始化或增加该卡牌的计数
							categories[type].items[card.name] =
								(categories[type].items[card.name] || 0) + 1;
							break; // 找到分类后跳出循环
						}
					}
				});

				let html = ''; // 初始化HTML字符串

				// 遍历所有分类
				for (const category of Object.values(categories)) {
					// 跳过没有卡牌的分类
					if (Object.keys(category.items).length === 0) continue;

					// 添加分类标题
					html += `<div class="category"><div class="category-title">${category.name}</div>`;

					// 对卡牌名称按中文排序
					const sorted = Object.entries(category.items)
						.sort((a, b) => a[0].localeCompare(b[0], 'zh-Hans-CN'));

					// 添加卡牌计数项
					html += sorted.map(([name, count]) =>
						`<div class="count-item">${name}：${count}</div>`
					).join('');

					html += '</div>'; // 关闭分类div
				}

				// 更新DOM显示
				document.getElementById('remaining-counts').innerHTML = html;
			}

			// 抽牌函数
			function drawCards(count) {
				// 检查牌堆是否为空
				if (deck.length === 0) {
					alert("牌堆已空，无法继续抽牌！");
					return;
				}

				// 如果抽牌数大于剩余牌数，自动调整
				if (deck.length < count) {
					alert(`牌堆仅剩${deck.length}张，自动抽取全部`);
					count = deck.length;
				}

				// 抽取指定数量的卡牌
				for (let i = 0; i < count; i++) {
					const drawnCard = deck.shift(); // 从牌堆顶部取出一张牌
					drawnCards.push(drawnCard); // 添加到已抽取卡牌列表
					hand.push(drawnCard); // 添加到玩家手牌

					// 特殊处理：抽到诸葛连弩（AK）时提示
					if (drawnCard.name === "诸葛连弩") {
						alert(`抽到AK！剩余牌堆：${deck.length}张`);
					}
				}

				// 更新界面
				updateRemaining(); // 更新剩余牌数显示
				updateReshuffleButton(); // 更新脚气卡按钮状态
				updateUI(); // 更新整体界面
			}

			// 展示剩余牌堆详情
			function revealDeck() {
				const container = document.getElementById('remaining');

				// 检查牌堆是否为空
				if (deck.length === 0) {
					container.innerHTML = `<h3>剩余牌堆 (0张)</h3><p>牌堆已空</p>`;
					return;
				}

				// 显示牌堆标题
				container.innerHTML = `<h3>剩余牌堆 (${deck.length}张)</h3>`;

				// 遍历牌堆中的每张牌
				deck.forEach((card, index) => {
					// 添加每张牌的详细信息
					container.innerHTML += `
						<div class="card">
							${index + 1}. ${card.name} ${card.suit}${getPointDisplay(card.point)}
						</div>`;
				});
			}

			// 高亮显示诸葛连弩（AK）
			function highlightZhugeLianNu() {
				const remainingCards = document.querySelectorAll('#remaining .card');

				// 检查牌堆是否为空
				if (deck.length === 0) {
					alert("牌堆已空，没有诸葛连弩！");
					return;
				}

				// 找出所有AK牌
				const akCards = Array.from(remainingCards).filter(card =>
					card.textContent.includes('诸葛连弩')
				);

				// 为AK牌添加高亮样式
				akCards.forEach(card => card.classList.add('highlight'));

				// 获取AK牌的位置
				const indices = akCards.map(card =>
					Array.from(remainingCards).indexOf(card) + 1
				);

				// 显示提示信息
				indices.length > 0 ?
					alert(`诸葛连弩位置：${indices.join(', ')}`) :
					alert("剩余牌堆中没有诸葛连弩！");
			}

			// 更新剩余牌数显示
			function updateRemaining() {
				// 显示剩余牌数
				document.getElementById('remaining').innerHTML = `剩余牌堆: ${deck.length}张`;

				// 更新各类卡牌计数
				updateRemainingCounts();
			}

			// 处理脚气卡使用（重新洗牌）
			function handleReshuffle() {
				// 验证脚气卡使用条件
				if (!validateReshuffle()) return;

				// 记录日志
				log(`开始使用脚气卡（当前已用${reshuffleUsed}次）`);

				// 回收当前手牌
				const currentDrawn = hand.splice(-4, 4);
				log(`回收手牌：${currentDrawn.map(c => c.name).join(', ')}`);

				// 将手牌放回牌堆顶部
				deck.unshift(...currentDrawn);

				// 洗牌
				shuffleDeck();

				// 更新脚气卡使用次数
				reshuffleUsed++;
				log(`脚气卡洗牌完成（${reshuffleUsed}/${MAX_RESHUFLE}次）`);

				// 清空已抽取牌堆
				discardPile.push(...drawnCards);
				drawnCards = [];

				// 重新抽牌
				drawCards(4);
				log(`重新抽取4张牌，剩余牌堆：${deck.length}张`);

				// 更新界面
				updateCounter();
				updateReshuffleButton();
			}

			// 验证脚气卡使用条件
			function validateReshuffle() {
				// 脚气卡使用条件：手牌4张、未达使用上限、牌堆+手牌≥4
				const isValid = hand.length === 4 &&
					reshuffleUsed < MAX_RESHUFLE &&
					deck.length + hand.length >= 4;

				// 记录无效尝试日志
				if (!isValid) {
					log(`脚气卡使用失败，验证条件不满足：
					手牌数: ${hand.length}
					已用次数: ${reshuffleUsed}
					剩余牌数: ${deck.length}`);
				}

				return isValid;
			}

			// 清空牌堆显示
			function clearDisplay() {
				document.getElementById('deck').innerHTML = '';
			}

			// 更新脚气卡按钮状态
			function updateReshuffleButton() {
				const btn = document.getElementById('reshuffleBtn');

				// 按钮启用条件：已抽4张牌且未达使用上限
				btn.disabled = !(drawnCards.length === 4 && reshuffleUsed < MAX_RESHUFLE);
			}

			// 洗牌函数
			function shuffleDeck() {
				// Fisher-Yates洗牌算法
				for (let i = deck.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[deck[i], deck[j]] = [deck[j], deck[i]];
				}

				// 如果装备的武器不在牌堆中，重置武器状态
				if (!deck.some(c => c.name === currentWeapon)) {
					currentWeapon = null;
					hasZhugeLianNu = false;
					killCount = 2;
				}

				// 重置桃和酒的使用次数
				peachCount = 1;
				document.getElementById('peach-counter').textContent = `桃可用次数：1`;
				wineCount = 1;

				// 更新状态
				updateStatus();

				// 生成新的AES编码
				generateDeckAES();
				updateAESDisplay();
			}

			// 开始游戏
			function startGame() {
				drawCards(4); // 初始抽4张牌
				phase = '准备'; // 设置游戏阶段

				// 设置按钮状态
				document.getElementById('drawBtn').disabled = false; // 摸牌阶段可用
				document.getElementById('playBtn').disabled = true; // 出牌阶段禁用

				// 更新界面
				updateUI();
			}

			// 初始化按钮状态
			function initializeButtons() {
				document.getElementById('drawBtn').disabled = false; // 摸牌阶段可用
				document.getElementById('playBtn').disabled = true; // 出牌阶段禁用
			}

			// 摸牌阶段处理
			function drawPhase() {
				// 检查牌堆是否为空
				if (deck.length === 0) {
					alert("牌堆已空，无法摸牌！");
					return;
				}

				// 设置游戏阶段为"摸牌"
				phase = '摸牌';

				// 摸3张牌
				drawCards(3);

				// 更新按钮状态
				document.getElementById('drawBtn').disabled = true; // 禁用摸牌按钮
				document.getElementById('playBtn').disabled = false; // 启用出牌按钮

				// 更新界面
				updateUI();
			}

			// 出牌阶段处理
			function playPhase() {
				// 设置游戏阶段为"出牌"
				phase = '出牌';

				// 重置最后使用的卡牌
				lastUsedCard = null;

				// 更新按钮状态
				document.getElementById('drawBtn').disabled = true; // 禁用摸牌按钮
				document.getElementById('playBtn').disabled = true; // 禁用出牌按钮
				document.getElementById('endPlayBtn').disabled = false; // 启用结束出牌按钮

				// 更新界面
				updateUI();
			}

			// 使用卡牌
			function useCard(card, index) {
				// 只能在出牌阶段使用卡牌
				if (phase !== '出牌') return;

				// 记录使用卡牌日志
				log(`使用卡牌：${card.name} ${card.suit}${getPointDisplay(card.point)}`);

				// 武器类卡牌处理
				if (cardCategories.weapon.includes(card.name)) {
					// 如果已装备其他武器，先卸除
					if (currentWeapon && currentWeapon !== card.name) {
						// 如果卸除的是诸葛连弩，重置杀次数
						if (currentWeapon === "诸葛连弩") {
							hasZhugeLianNu = false;
							killCount = 2;
							log(`卸除诸葛连弩，杀次数重置为2`);
						}
					}

					// 装备新武器
					currentWeapon = card.name;
					hasZhugeLianNu = (card.name === "诸葛连弩");

					// 如果是诸葛连弩，记录日志
					if (hasZhugeLianNu) {
						log("装备诸葛连弩，杀次数限制解除");
					}
				}
				// 延时锦囊处理
				if (["兵粮寸断", "乐不思蜀","闪电"].includes(card.name)) {
				    if (handleDelayCard(card, index)) return;
				}


				// 杀类卡牌处理
				if (['杀', '火杀', '雷杀'].includes(card.name)) {
					// 如果没有装备诸葛连弩
					if (!hasZhugeLianNu) {
						// 检查杀次数是否用尽
						if (killCount <= 0) {
							alert("杀次数已用尽！");
							return;
						}
						// 减少杀次数并记录
						killCount--;
						log(`使用${card.name}，剩余次数：${killCount}`);
					}
				}

				// 特殊卡牌：诸葛连弩
				if (card.name === "诸葛连弩") {
					hasZhugeLianNu = true;
					log("装备诸葛连弩，杀次数限制解除！");
				}

				// 特殊卡牌：无中生有
				if (card.name === "无中生有") {
					log('使用无中生有，额外摸两张牌！');
					drawCards(2); // 摸两张牌
				}

				//顺手牵羊
				if (card.name === "顺手牵羊") {
					log('使用顺手牵羊，额外摸一张牌');
					drawCards(1); //摸一张牌
				}

				// 禁止使用的卡牌：闪
				if (card.name === '闪') {
					alert("出牌阶段禁止使用闪！");
					return; // 提前返回，不执行后续操作
				}

				// 禁止使用的卡牌：无懈可击
				if (card.name === '无懈可击') {
					alert("出牌阶段禁止使用无懈可击");
					return; // 提前返回，不执行后续操作
				}

				// 特殊卡牌：铁索连环
				if (card.name === "铁索连环") {
					showChainDialog(card, index); // 显示选择对话框
					return; // 提前返回，对话框会处理后续操作
				}

				//五谷丰登
				if (card.name === "五谷丰登") {
					showWugufengdengDialog(card, index); // 显示选择对话框
					return; // 提前返回，对话框会处理后续操作
				}

				// 特殊卡牌：借刀杀人
				if (card.name === "借刀杀人") {
					showJiedaoDialog(card, index); // 显示选择对话框
					return; // 提前返回，对话框会处理后续操作
				}

				// 桃类卡牌处理
				if (card.name === "桃") {
					// 检查桃使用次数
					if (peachCount <= 0) {
						alert("桃使用次数已耗尽！");
						return;
					}
					// 减少桃次数并记录
					peachCount--;
					log(`使用桃，剩余次数：${peachCount}`);
				}

				// 特殊卡牌：桃园结义
				if (card.name === "桃园结义") {
					// 减少桃次数（至少为0）
					peachCount = Math.max(peachCount - 1, 0);
					log(`使用桃园结义恢复体力，剩余次数：${peachCount}`);
				}

				// 酒类卡牌处理
				if (card.name === "酒") {
					// 检查酒使用次数
					if (wineCount <= 0) {
						alert("酒使用次数已耗尽！");
						return;
					}
					// 减少酒次数并记录
					wineCount--;
					log(`使用酒，剩余次数：${wineCount}`);
				}

				// 渐营技能检查（连续使用相同花色或点数的牌）
				if (lastUsedCard && (card.suit === lastUsedCard.suit || card.point === lastUsedCard.point)) {
					log('触发渐营，摸一张牌！');
					drawCards(1); // 额外摸一张牌
				}

				// 更新最后使用的卡牌
				lastUsedCard = card;

				// 从手牌移除并放入弃牌堆
				discardPile.push(hand.splice(index, 1)[0]);

				// 更新状态和界面
				updateStatus();
				updateUI();
			}

			// 更新状态显示
			function updateStatus() {
				// 获取DOM元素
				const counter = document.getElementById('kill-counter');
				const zhuge = document.getElementById('zhuge-status');

				// 更新桃和酒的使用次数
				document.getElementById('peach-counter').textContent = `桃可用次数：${peachCount}`;
				document.getElementById('wine-counter').textContent = `酒可用次数：${wineCount}`;

				// 更新杀次数显示（根据是否装备诸葛连弩）
				counter.innerHTML = hasZhugeLianNu ?
					'杀可用次数：∞' : // 无限次
					`杀可用次数：${killCount}`; // 显示剩余次数

				// 更新武器状态
				zhuge.textContent = currentWeapon ?
					`当前武器：${currentWeapon}` : // 显示当前武器
					"当前武器：无"; // 没有装备武器

				// 更新延时锦囊显示
				updateDelayArea();
			}

			// 更新延时锦囊区域显示
			function updateDelayArea() {
			    const bingliangContainer = document.getElementById('bingliang-container');
			    const lebuContainer = document.getElementById('lebu-container');
			    const shandianContainer = document.getElementById('shandian-container'); // 新增
			    
			    // 清空容器
			    bingliangContainer.innerHTML = '';
			    lebuContainer.innerHTML = '';
			    shandianContainer.innerHTML = ''; // 新增
			    
			    // 兵粮寸断区域
			    if (bingliangArea.length === 0) {
			        bingliangContainer.innerHTML = '<div class="delay-card disabled">空</div>';
			    } else {
			        bingliangArea.forEach(card => {
			            const cardDiv = document.createElement('div');
			            cardDiv.className = 'delay-card';
			            cardDiv.textContent = `${card.name} ${card.suit}${getPointDisplay(card.point)}`;
			            bingliangContainer.appendChild(cardDiv);
			        });
			    }
			    
			    // 乐不思蜀区域
			    if (lebuArea.length === 0) {
			        lebuContainer.innerHTML = '<div class="delay-card disabled">空</div>';
			    } else {
			        lebuArea.forEach(card => {
			            const cardDiv = document.createElement('div');
			            cardDiv.className = 'delay-card';
			            cardDiv.textContent = `${card.name} ${card.suit}${getPointDisplay(card.point)}`;
			            lebuContainer.appendChild(cardDiv);
			        });
			    }
			    
			    // 闪电区域
			    if (shandianArea.length === 0) {
			        shandianContainer.innerHTML = '<div class="delay-card disabled">空</div>';
			    } else {
			        shandianArea.forEach(card => {
			            const cardDiv = document.createElement('div');
			            cardDiv.className = 'delay-card';
			            cardDiv.textContent = `${card.name} ${card.suit}${getPointDisplay(card.point)}`;
			            shandianContainer.appendChild(cardDiv);
			        });
			    }
			}

			// 处理延时锦囊牌使用
			function handleDelayCard(card, index) {
			    let targetArea, areaName, maxCards;
			    
			    switch(card.name) {
			        case "兵粮寸断":
			            targetArea = bingliangArea;
			            areaName = "兵粮寸断";
			            maxCards = MAX_DELAY_CARDS;
			            break;
			        case "乐不思蜀":
			            targetArea = lebuArea;
			            areaName = "乐不思蜀";
			            maxCards = MAX_DELAY_CARDS;
			            break;
			        case "闪电": 
			            targetArea = shandianArea;
			            areaName = "闪电";
			            maxCards = MAX_SHANDIAN;
			            break;
			        default:
			            return false;
			    }
			    
			    if (targetArea.length >= maxCards) {
			        alert(`${areaName}已达上限（${maxCards}张），无法使用！`);
			        return true;
			    }
			    
			    // 从手牌移除
			    const usedCard = hand.splice(index, 1)[0];
			    
			    // 放入状态区
			    targetArea.push(usedCard);
			    
			    log(`使用${card.name}，放入${areaName}区`);
			    
			    // 更新状态
			    updateStatus();
			    updateUI();
			    
			    return true;
			}


			//五谷丰登对话框
			function showWugufengdengDialog(card, index) {
				// 检查牌堆是否足够
				if (deck.length < 3) {
					alert(`牌堆不足3张，无法使用五谷丰登！当前牌堆: ${deck.length}张`);
					return;
				}

				// 创建模态背景
				const overlay = document.createElement('div');
				overlay.className = 'modal-backdrop';
				overlay.style.zIndex = '10000';

				// 创建对话框
				const dialog = document.createElement('div');
				dialog.className = 'wugufengdeng-dialog';
				dialog.style = `
			        position: fixed;
			        top: 50%;
			        left: 50%;
			        transform: translate(-50%, -50%);
			        background: #ffecb3;
			        padding: 20px;
			        border-radius: 10px;
			        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
			        z-index: 10001;
			        min-width: 350px;
			        text-align: center;
			    `;

			 // 添加标题
				dialog.innerHTML = `
			        <h3 style="color:#5d4037; margin-top:0;">五谷丰登 - 请选择一张牌</h3>
			        <div class="card-options" style="display: flex; justify-content: center; gap: 20px; margin: 20px 0;">
			            <!-- 卡牌选项将由JS动态添加 -->
			        </div>
			        <p style="color:#795548;">剩余两张牌将置入弃牌堆</p>
			    `;

				// 从牌堆顶部取三张牌
				const cardsToShow = deck.slice(0, 3);
				const cardOptions = dialog.querySelector('.card-options');

				// 创建三张牌的选项
				cardsToShow.forEach((cardObj, i) => {
					const cardDiv = document.createElement('div');
					cardDiv.className = 'wugufengdeng-card';
					cardDiv.style = `
			            border: 2px solid #8d6e63;
			            border-radius: 8px;
			            padding: 15px;
			            background: #fff8e1;
			            cursor: pointer;
			            transition: all 0.3s;
			            min-width: 100px;
			        `;

					cardDiv.innerHTML = `
			            <div style="font-size: 18px; font-weight: bold; color:#5d4037;">${cardObj.name}</div>
			            <div style="font-size: 24px;">${cardObj.suit}${getPointDisplay(cardObj.point)}</div>
			            <div style="font-size: 14px; color:#8d6e63;">点击选择</div>
			        `;

					cardDiv.addEventListener('click', () => handleWugufengdengSelection(card, index, i, cardsToShow));
					cardDiv.addEventListener('mouseenter', () => {
						cardDiv.style.transform = 'translateY(-5px)';
						cardDiv.style.boxShadow = '0 6px 12px rgba(0,0,0,0.15)';
					});
					cardDiv.addEventListener('mouseleave', () => {
						cardDiv.style.transform = 'none';
						cardDiv.style.boxShadow = 'none';
					});

					cardOptions.appendChild(cardDiv);
				});

				// 添加关闭按钮
				const closeBtn = document.createElement('button');
				closeBtn.textContent = '关闭';
				closeBtn.style = `
			        padding: 8px 20px;
			        background: #8d6e63;
			        color: white;
			        border: none;
			        border-radius: 4px;
			        cursor: pointer;
			        margin-top: 10px;
			    `;
				closeBtn.addEventListener('click', () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
				});

				dialog.appendChild(closeBtn);

				// 添加元素到DOM
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
			}

			// 处理五谷丰登选择
			function handleWugufengdengSelection(wugufengdengCard, handIndex, selectedIndex, shownCards) {
				// 关闭所有对话框
				document.querySelectorAll('.modal-backdrop, .wugufengdeng-dialog').forEach(el => el.remove());

				// 选中的卡牌
				const selectedCard = shownCards[selectedIndex];

				// 从牌堆中移除展示的三张牌
				const removedCards = deck.splice(0, 3);

				// 添加选中的牌到玩家手牌
				hand.push(selectedCard);
				log(`五谷丰登获得: ${selectedCard.name} ${selectedCard.suit}${getPointDisplay(selectedCard.point)}`);

				// 其余两张牌置入弃牌堆
				shownCards.forEach((card, i) => {
					if (i !== selectedIndex) {
						discardPile.push(card);
						log(`弃置: ${card.name} ${card.suit}${getPointDisplay(card.point)}`);
					}
				});

				// 从手牌中移除五谷丰登
				const usedCard = hand.splice(handIndex, 1)[0];
				discardPile.push(usedCard);
				log(`使用五谷丰登`);

				// 检查渐营技能
				if (lastUsedCard && (wugufengdengCard.suit === lastUsedCard.suit || wugufengdengCard.point === lastUsedCard
						.point)) {
					log('触发渐营，摸一张牌！');
					drawCards(1);
				}

				// 更新最后使用的卡牌
				lastUsedCard = wugufengdengCard;

				// 更新界面
				updateUI();
				updateRemaining();

				// 显示操作反馈
				showFeedback(`已选择: ${selectedCard.name}`);
			}

			// 添加反馈消息函数
			function showFeedback(message) {
				const feedback = document.createElement('div');
				feedback.textContent = message;
				feedback.style = `
			        position: fixed;
			        top: 20px;
			        left: 50%;
			        transform: translateX(-50%);
			        padding: 12px 25px;
			        background: #4CAF50;
			        color: white;
			        border-radius: 30px;
			        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
			        z-index: 10000;
			        font-weight: bold;
			        animation: fadeInOut 2.5s forwards;
			    `;

				// 添加淡入淡出动画
				const style = document.createElement('style');
				style.textContent = `
			        @keyframes fadeInOut {
			            0% { opacity: 0; top: 10px; }
			            20% { opacity: 1; top: 20px; }
			            80% { opacity: 1; top: 20px; }
			            100% { opacity: 0; top: 10px; }
			        }
			    `;
				document.head.appendChild(style);

				document.body.appendChild(feedback);

				// 2.5秒后移除
				setTimeout(() => {
					if (document.body.contains(feedback)) {
						document.body.removeChild(feedback);
					}
				}, 2500);
			}

			// 铁索连环卡牌效果选择对话框
			function showChainDialog(card, index) {
				// 创建对话框元素
				const dialog = document.createElement('div');
				dialog.style = `
					position: fixed;
					top: 50%;
					left: 50%;
					transform: translate(-50%, -50%);
					background: white;
					padding: 20px;
					border: 2px solid #666;
					z-index: 10000;
					box-shadow: 0 0 10px rgba(0,0,0,0.5);
				`;

				// 对话框内容
				dialog.innerHTML = `
					<h3>铁索连环效果选择</h3>
					<p>请选择要执行的操作：</p>
					<button id="func1" style="margin:5px; padding:8px; background:#BBDEFB;">功能1：重铸摸牌</button>
					<button id="func2" style="margin:5px; padding:8px; background:#C8E6C9;">功能2：使用检索</button>
					<button id="cancel" style="margin:5px; padding:8px; background:#FFCDD2;">取消</button>
				`;

				// 创建模态背景
				const overlay = document.createElement('div');
				overlay.style = `
					position: fixed;
					top: 0;
					left: 0;
					right: 0;
					bottom: 0;
					background: rgba(0,0,0,0.5);
					z-index: 9999;
				`;

				// 功能1：重铸摸牌
				dialog.querySelector('#func1').addEventListener('click', () => {
					// 从手牌移除铁索连环
					hand.splice(index, 1);

					// 加入弃牌堆
					discardPile.push(card);

					// 摸一张牌
					drawCards(1);

					// 记录日志
					log(`重铸铁索连环，摸1张牌`);

					// 关闭对话框
					cleanupDialog();
				});

				// 功能2：使用检索
				dialog.querySelector('#func2').addEventListener('click', () => {
					// 检查渐营技能是否触发
					if (lastUsedCard && (card.suit === lastUsedCard.suit || card.point === lastUsedCard.point)) {
						log('触发渐营，摸一张牌！');
						drawCards(1);
					}

					// 更新最后使用的卡牌
					lastUsedCard = card;

					// 从手牌移除并加入弃牌堆
					discardPile.push(hand.splice(index, 1)[0]);

					// 记录日志
					log(`使用铁索连环，花色${card.suit} 点数${getPointDisplay(card.point)}`);

					// 关闭对话框
					cleanupDialog();
				});

				// 取消按钮
				dialog.querySelector('#cancel').addEventListener('click', cleanupDialog);

				// 关闭对话框的函数
				function cleanupDialog() {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
					updateUI(); // 更新界面
				}

				// 添加元素到DOM
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
			}

			// 借刀杀人卡牌效果选择对话框
			function showJiedaoDialog(card, index) {
				// 创建模态背景
				const overlay = document.createElement('div');
				overlay.className = 'modal-backdrop';

				// 创建对话框
				const dialog = document.createElement('div');
				dialog.className = 'card-selector-modal';
				dialog.innerHTML = `
					<h3>借刀杀人效果选择</h3>
					<p>请选择要执行的操作：</p>
					<div style="display: flex; flex-direction: column; gap: 10px;">
						<button id="func1" class="dialog-button" style="background:#BBDEFB;">功能1：检索武器</button>
						<button id="func2" class="dialog-button" style="background:#C8E6C9;">功能2：使用闪</button>
						<button id="cancel" class="dialog-button cancel" style="background:#FFCDD2;">取消</button>
					</div>
				`;

				// 关闭所有弹窗的函数
				const closeAllModals = () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
				};

				// 功能1：检索武器
				dialog.querySelector('#func1').addEventListener('click', () => {
					closeAllModals(); // 关闭当前对话框

					// 获取牌堆中的所有武器牌
					const weaponCards = deck.filter(c => cardCategories.weapon.includes(c.name));

					// 检查是否有武器牌
					if (weaponCards.length === 0) {
						alert("牌堆中没有武器牌！");
						return;
					}

					// 获取第一张武器牌（随机选择更合理，这里简化处理）
					const weaponCard = weaponCards[0];

					// 在牌堆中查找该武器牌的位置
					const deckIndex = deck.findIndex(c => c.uid === weaponCard.uid);

					// 安全验证
					if (deckIndex === -1) {
						console.error(`武器牌 ${weaponCard.name} 不存在于牌堆中`);
						return;
					}

					// 从牌堆中移除武器牌
					const [removed] = deck.splice(deckIndex, 1);

					// 添加到手牌
					hand.push(removed);

					// 记录日志
					log(`检索获得武器：${removed.name} ${removed.suit}${getPointDisplay(removed.point)}`);

					// 完成借刀杀人效果
					finalizeJiedao(card, index);
				});

				// 功能2：使用闪
				dialog.querySelector('#func2').addEventListener('click', () => {
					closeAllModals(); // 关闭当前对话框

					// 获取手牌中的所有闪牌
					const shanCards = hand.filter(c => c.name === "闪");

					// 检查是否有闪牌
					if (shanCards.length === 0) {
						// 没有闪牌时显示特殊对话框
						showNoShanDialog(card, index);
					} else {
						// 有闪牌时显示选择对话框
						showShanSelection(shanCards, card, index);
					}

					// 完成借刀杀人效果
					finalizeJiedao(card, index);
				});

				// 取消按钮
				dialog.querySelector('#cancel').addEventListener('click', () => {
					closeAllModals();
					log("取消使用借刀杀人");
				});

				// 点击背景关闭
				overlay.addEventListener('click', (e) => {
					if (e.target === overlay) {
						closeAllModals();
						log("取消使用借刀杀人");
					}
				});

				// 添加元素到DOM
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
			}

			// 没有闪牌时的对话框
			function showNoShanDialog(card, index) {
				// 创建对话框
				const dialog = document.createElement('div');
				dialog.className = 'card-selector-modal';
				dialog.innerHTML = `
					<h3>没有闪牌</h3>
					<p>请选择后续操作：</p>
					<button class="dialog-button" id="cancelUse">取消使用</button>
					<button class="dialog-button" id="noShan">坚持不出闪</button>
				`;

				// 创建模态背景
				const overlay = document.createElement('div');
				overlay.className = 'modal-backdrop';

				// 取消使用按钮
				dialog.querySelector('#cancelUse').addEventListener('click', () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);
				});

				// 坚持不出闪按钮
				dialog.querySelector('#noShan').addEventListener('click', () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);

					// 增加桃使用次数（最多3次）
					peachCount = Math.min(peachCount + 1, 3);
					log(`不出闪，桃可用次数+1，当前：${peachCount}`);

					// 完成借刀杀人效果
					finalizeJiedao(card, index);
				});

				// 添加元素到DOM
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
			}

			// 选择要使用的闪牌对话框
			function showShanSelection(shanCards, card, index) {
				// 创建对话框
				const dialog = document.createElement('div');
				dialog.className = 'card-selector-modal';
				dialog.innerHTML = `
					<h3>选择要使用的闪牌</h3>
					<div id="shanList" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 15px 0;">
						${shanCards.map((c, i) => `
							<button class="shan-card" data-index="${i}">
								${c.suit}${getPointDisplay(c.point)}
							</button>
						`).join('')}
					</div>
					<button class="dialog-button cancel" id="cancelShan">取消使用闪</button>
				`;

				// 创建模态背景
				const overlay = document.createElement('div');
				overlay.className = 'modal-backdrop';

				// 闪牌选择事件
				dialog.querySelectorAll('.shan-card').forEach(btn => {
					btn.addEventListener('click', (e) => {
						// 获取选中的闪牌索引
						const idx = parseInt(e.target.dataset.index);
						const selectedCard = shanCards[idx];

						// 在手牌中查找该闪牌
						const handIndex = hand.findIndex(c => c.uid === selectedCard.uid);

						// 如果找到则使用该闪牌
						if (handIndex > -1) {
							const [removed] = hand.splice(handIndex, 1);
							discardPile.push(removed);
							log(`使用闪牌：${removed.suit}${getPointDisplay(removed.point)}`);
						}

						// 关闭对话框
						document.body.removeChild(overlay);
						document.body.removeChild(dialog);

						// 完成借刀杀人效果
						finalizeJiedao(card, index);
					});
				});

				// 取消使用闪按钮
				dialog.querySelector('#cancelShan').addEventListener('click', () => {
					document.body.removeChild(overlay);
					document.body.removeChild(dialog);

					// 增加桃使用次数（最多3次）
					peachCount = Math.min(peachCount + 1, 3);
					log(`取消使用闪，桃可用次数+1，当前：${peachCount}`);

					// 完成借刀杀人效果
					finalizeJiedao(card, index);
				});

				// 添加元素到DOM
				document.body.appendChild(overlay);
				document.body.appendChild(dialog);
			}

			// 完成借刀杀人效果
			function finalizeJiedao(card, index) {
				// 从手牌中移除借刀杀人卡牌
				const jiedaoCard = hand.splice(index, 1)[0];
				discardPile.push(jiedaoCard);

				// 检查渐营技能
				if (lastUsedCard &&
					(jiedaoCard.suit === lastUsedCard.suit ||
						jiedaoCard.point === lastUsedCard.point)) {
					log('触发渐营，摸一张牌！');
					drawCards(1);
				}

				// 更新最后使用的卡牌
				lastUsedCard = jiedaoCard;

				// 更新界面和状态
				updateUI();
				updateStatus();
			}

			// 清理所有对话框
			function cleanupDialog() {
				// 选择所有模态背景和对话框
				const dialogs = document.querySelectorAll('.modal-backdrop, .card-selector-modal');

				// 移除它们
				dialogs.forEach(dialog => dialog.remove());
			}

			// 更新游戏界面
			function updateUI() {
				// 更新阶段信息
				const stageInfo = document.getElementById('stageInfo');
				if (stageInfo) {
					stageInfo.textContent = `当前阶段：${phase}阶段`;
				}

				// 更新手牌显示
				const handDiv = document.getElementById('hand');
				handDiv.innerHTML = '<h3>手牌</h3>';

				// 遍历手牌
				hand.forEach((card, i) => {
					const div = document.createElement('div');
					div.className = 'card';

					// 杀类卡牌禁用检查
					if (['杀', '火杀', '雷杀'].includes(card.name)) {
						if (!hasZhugeLianNu && killCount <= 0) {
							div.classList.add('disabled');
						}
					}

					// 桃禁用检查
					if (card.name === "桃" && peachCount <= 0) {
						div.classList.add('disabled');
					}

					// 酒禁用检查
					if (card.name === "酒" && wineCount <= 0) {
						div.classList.add('disabled');
					}

					// 闪禁用处理
					if (card.name === '闪') {
						div.classList.add('disabled');
						div.onclick = () => alert("出牌阶段无法使用闪！");
					}

					// 无懈可击禁用处理
					if (card.name === '无懈可击') {
						div.classList.add('disabled');
						div.onclick = () => alert("出牌阶段无法使用无懈可击");
					}

					// 延时锦囊牌禁用检查
					if (card.name === "兵粮寸断" && bingliangArea.length >= MAX_DELAY_CARDS) {
						div.classList.add('disabled');
						div.onclick = () => alert("兵粮寸断已达上限，无法使用！");
					}

					if (card.name === "乐不思蜀" && lebuArea.length >= MAX_DELAY_CARDS) {
						div.classList.add('disabled');
						div.onclick = () => alert("乐不思蜀已达上限，无法使用！");
					}
					
					if (card.name === "闪电" && shandianArea.length >= MAX_SHANDIAN) {
					    div.classList.add('disabled');
					    div.onclick = () => alert("闪电已达上限，无法使用！");
					}


					// 设置卡牌内容
					div.innerHTML = `${card.name}<br>${card.suit}${getPointDisplay(card.point)}`;

					// 添加点击事件（禁用卡牌除外）
					if (!div.classList.contains('disabled')) {
						div.onclick = () => useCard(card, i);
					}

					// 添加到手牌区域
					handDiv.appendChild(div);
				});

				// 更新按钮状态
				document.getElementById('playBtn').disabled = phase !== '摸牌';
				document.getElementById('endPlayBtn').disabled = phase !== '出牌';
			}

			// 结束出牌阶段
			function endPlayPhase() {
				// 设置游戏阶段为准备阶段
				phase = '准备';

				// 重置最后使用的卡牌
				lastUsedCard = null;

				// 更新按钮状态
				document.getElementById('drawBtn').disabled = false; // 启用摸牌按钮
				document.getElementById('endPlayBtn').disabled = true; // 禁用结束出牌按钮
				document.getElementById('playBtn').disabled = true; // 禁用出牌按钮

				// 武器状态处理
				if (currentWeapon !== "诸葛连弩") {
					// 如果不是诸葛连弩，重置杀次数
					killCount = 2;
					hasZhugeLianNu = false;
				} else {
					// 保留诸葛连弩效果
					hasZhugeLianNu = true;
					log("保留诸葛连弩效果，杀次数保持无限");
				}

				// 重置酒使用次数
				wineCount = 1;

				// 清空延时锦囊区并放入弃牌堆
				clearDelayAreas();

				// 更新状态显示
				updateStatus();

				// 更新界面
				updateUI();

				// 记录日志
				log("已结束出牌阶段");
			}

			// 清空延时锦囊区
			function clearDelayAreas() {
			    if (bingliangArea.length > 0 || lebuArea.length > 0 || shandianArea.length > 0) {
			        log(`结束出牌阶段，清空延时锦囊区`);
			    }
			    
			    // 兵粮寸断区
			    bingliangArea.forEach(card => {
			        discardPile.push(card);
			        log(`弃置兵粮寸断: ${card.suit}${getPointDisplay(card.point)}`);
			    });
			    bingliangArea = [];
			    
			    // 乐不思蜀区
			    lebuArea.forEach(card => {
			        discardPile.push(card);
			        log(`弃置乐不思蜀: ${card.suit}${getPointDisplay(card.point)}`);
			    });
			    lebuArea = [];
			    
			    // 闪电区（新增）
			    shandianArea.forEach(card => {
			        discardPile.push(card);
			        log(`弃置闪电: ${card.suit}${getPointDisplay(card.point)}`);
			    });
			    shandianArea = [];
			    
			    updateStatus();
			}

			// 弃置卡牌
			function discardCard(card) {
				// 如果弃置的是诸葛连弩
				if (card.name === "诸葛连弩") {
					// 重置诸葛连弩状态
					hasZhugeLianNu = false;

					// 记录日志
					log("失去诸葛连弩，恢复次数限制");

					// 更新状态显示
					updateStatus();
				}
			}

			// 更新顶部操作栏占位符高度
			function updateHeaderPlaceholder() {
				// 获取顶部操作栏和占位元素
				const header = document.querySelector('.header');
				const placeholder = document.querySelector('.header-placeholder');

				// 确保元素存在
				if (header && placeholder) {
					// 计算高度（操作栏高度 + 5px缓冲）
					const height = header.offsetHeight + 5;

					// 设置占位元素高度
					placeholder.style.height = `${height}px`;
				}
			}

			// 页面加载和窗口大小变化时更新占位符
			window.addEventListener('DOMContentLoaded', updateHeaderPlaceholder);
			window.addEventListener('resize', updateHeaderPlaceholder);

			// 检测是否Windows系统
			function isWindowsOS() {
				// 检查用户代理是否包含"Win"关键词
				return navigator.userAgent.indexOf('Win') > -1;
			}

			// 生成安全日志内容
			function generateSecurityLog() {
				// 格式化当前时间
				const timeStamp = new Date().toISOString()
					.replace(/T/, ' ') // 将T替换为空格
					.replace(/\..+/, ''); // 移除毫秒部分

				// 生成牌堆详细信息
				const deckDetails = deck.map((card, index) =>
					`[${index + 1}] ${card.name} - 花色:${card.suit} 点数:${getPointDisplay(card.point)} UID:${card.uid}`
				).join('\n'); // 每张卡信息一行

				// 构建日志内容
				return `沮爹红利期模拟器安全日志\n
			    生成时间: ${timeStamp}
			    ==================== MD5 & AES ====================
			    MD5标识符: ${currentMD5}
			    AES编码: ${currentAES}
			    =================== 牌堆详细信息 ===================
			    总牌数: ${deck.length}
			    当前牌堆顺序:
			    ${deckDetails}
			    ==================== 系统信息 ======================
			    用户系统: ${navigator.userAgent}
			    `;
			}

			// 显示安全警告弹窗
			function showSecurityAlert() {
				// 创建警告弹窗
				const alertBox = document.createElement('div');
				alertBox.className = 'security-alert';
				alertBox.innerHTML = `
			        <strong>安全提示</strong>
			        <p>由于保障用户信息安全，该功能仅限Windows系统用户使用。该功能会在您的浏览器中生成一个包含本次牌堆的MD5、AES编码及牌堆详细信息的txt文件。</p>
			        <p>请问是否继续创建？</p>
			        <button class="confirm">是，继续创建</button>
			        <button class="cancel">否，取消操作</button>
			    `;

				// 创建模态背景
				const backdrop = document.createElement('div');
				backdrop.style = `
			        position: fixed;
			        top:0; left:0; right:0; bottom:0;
			        background: rgba(0,0,0,0.5);
			        display: flex;
			        align-items: center;
			        justify-content: center;
			        z-index: 9999;
			    `;

				// 添加弹窗到背景
				backdrop.appendChild(alertBox);
				document.body.appendChild(backdrop);

				// 返回Promise处理用户选择
				return new Promise(resolve => {
					// 确认按钮点击处理
					alertBox.querySelector('.confirm').onclick = () => {
						document.body.removeChild(backdrop);
						resolve(true);
					};

					// 取消按钮点击处理
					alertBox.querySelector('.cancel').onclick = () => {
						document.body.removeChild(backdrop);
						resolve(false);
					};
				});
			}

			// 绑定日志导出按钮事件
			document.getElementById('exportLog').addEventListener('click', async () => {
				// 检查操作系统
				if (!isWindowsOS()) {
					alert('当前功能仅限Windows系统用户使用');
					return;
				}

				// 显示安全警告并等待用户确认
				const userConfirm = await showSecurityAlert();
				if (!userConfirm) {
					log('用户取消了日志生成');
					return;
				}

				try {
					// 生成日志内容
					const content = generateSecurityLog();

					// 创建Blob对象
					const blob = new Blob([content], {
						type: 'text/plain;charset=utf-8'
					});

					// 创建下载链接
					const downloadLink = document.createElement('a');
					downloadLink.href = URL.createObjectURL(blob);
					downloadLink.download = `PileLog_${Date.now()}.txt`; // 唯一文件名

					// 添加链接到DOM并模拟点击
					document.body.appendChild(downloadLink);
					downloadLink.click();

					// 清理DOM
					document.body.removeChild(downloadLink);

					// 记录日志
					log('安全日志文件已生成');
				} catch (error) {
					// 错误处理
					console.error('导出失败:', error);
					log('安全日志生成失败');
				}
			});

			// 记录操作日志
			function log(message) {
				// 获取日志容器元素
				const logDiv = document.getElementById('log');
				const container = document.getElementById('log-container');

				// 创建新日志条目
				const newEntry = document.createElement('p');

				// 设置日志内容（带时间戳）
				newEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

				// 添加到日志容器
				logDiv.appendChild(newEntry);

				// 滚动到顶部（最新日志）
				container.scrollTop = 0;
			}

			// 记牌器折叠/展开状态
			let isCollapsed = false;

			// 绑定记牌器折叠按钮事件
			document.getElementById('toggleCounter').addEventListener('click', () => {
				// 获取记牌器元素和按钮
				const counter = document.getElementById('remaining-counts');
				const btn = document.getElementById('toggleCounter');

				// 切换折叠状态
				isCollapsed = !isCollapsed;

				// 切换CSS类
				counter.classList.toggle('collapsed');

				// 更新按钮文本
				btn.innerHTML = isCollapsed ? '▶ 展开' : '▼ 收起';
			});

			// 通用折叠/展开函数
			function toggleSection(sectionId, button, isCollapsedFlag) {
				// 获取目标元素
				const section = document.getElementById(sectionId);

				// 切换状态
				isCollapsedFlag = !isCollapsedFlag;

				// 切换CSS类
				section.classList.toggle('collapsed');

				// 更新按钮文本
				button.innerHTML = isCollapsedFlag ? '▶ 展开' : '▼ 收起';

				// 返回新状态
				return isCollapsedFlag;
			}

			// 绑定安全校验区折叠按钮事件
			document.getElementById('toggleMD5AES').addEventListener('click', () => {
				// 使用通用函数切换MD5/AES区域
				isMD5AESCollapsed = toggleSection(
					'md5aes-container',
					document.getElementById('toggleMD5AES'),
					isMD5AESCollapsed
				);
			});

			// 键盘快捷键处理
			function handleKeyPress(event) {
				// 如果焦点在输入框，则忽略
				if (document.activeElement.tagName === 'INPUT') return;

				// 获取按钮状态
				const reshuffleDisabled = document.getElementById('reshuffleBtn').disabled;
				const playBtnDisabled = document.getElementById('playBtn').disabled;
				const endPlayDisabled = document.getElementById('endPlayBtn').disabled;

				// 处理快捷键
				switch (event.key.toUpperCase()) {
					case 'Q': // 强制刷新
						if (confirm("确定要强制刷新页面吗？")) {
							location.reload(true);
						}
						break;
					case '1': // 发1张牌
						drawCards(1);
						break;
					case '2': // 发2张牌
						drawCards(2);
						break;
					case '3': // 发3张牌
						drawCards(3);
						break;
					case '4': // 发4张牌
						drawCards(4);
						break;
					case 'W': // 查看剩余牌堆
						revealDeck();
						break;
					case 'E': // 高亮诸葛连弩
						highlightZhugeLianNu();
						break;
					case 'R': // 重新洗牌
						initializeDeck();
						log("快捷键洗牌");
						break;
					case 'T': // 使用脚气卡
						if (!reshuffleDisabled) handleReshuffle();
						break;
					case 'A': // 进入摸牌阶段
						if (phase === '准备') drawPhase();
						break;
					case 'S': // 进入出牌阶段
						if (!playBtnDisabled) playPhase();
						break;
					case 'D': // 结束出牌阶段
						if (!endPlayDisabled) endPlayPhase();
						break;
				}

				// 阻止这些键的默认行为
				if ('QWEASDTR1234'.includes(event.key.toUpperCase())) {
					event.preventDefault();
				}
			}

			// 获取卡牌分类
			function getCardCategory(cardName) {
				// 遍历外部定义的卡牌分类
				for (const category in cardCategories) {
					// 检查卡牌是否属于此分类
					if (cardCategories[category].includes(cardName)) {
						return category;
					}
				}
				// 未找到分类
				return "unknown";
			}

			// 显示卡牌选择器对话框
			function showCardSelector() {
				// 创建模态背景
				const backdrop = document.createElement('div');
				backdrop.className = 'modal-backdrop';

				// 创建对话框
				const modal = document.createElement('div');
				modal.className = 'card-selector-modal';
				modal.innerHTML = `
					<h3>选择要添加的卡牌类型</h3>
					<div id="cardButtons"></div>
					<button onclick="this.parentElement.parentElement.remove()" 
							style="margin-top:15px; padding:8px 20px;">
						关闭
					</button>
				`;

				// 获取按钮容器
				const buttonsContainer = modal.querySelector('#cardButtons');

				// 获取所有卡牌类型
				const types = getAllCardTypes();

				// 为每种卡牌类型创建按钮
				types.forEach(type => {
					const btn = document.createElement('button');
					btn.className = 'card-button';
					btn.textContent = type;
					btn.onclick = () => {
						// 添加选择的卡牌类型
						addSpecificCard(type);
						// 关闭对话框
						backdrop.remove();
					};
					buttonsContainer.appendChild(btn);
				});

				// 添加对话框到背景
				backdrop.appendChild(modal);
				// 添加到文档
				document.body.appendChild(backdrop);

				// 点击背景关闭对话框
				backdrop.onclick = (e) => {
					if (e.target === backdrop) {
						backdrop.remove();
					}
				};
			}

			// 绑定测试按钮事件
			document.getElementById('testCardBtn').addEventListener('click', showCardSelector);

			// 获取所有卡牌类型
			function getAllCardTypes() {
				// 使用Set去重
				const typeSet = new Set();

				// 遍历标准牌堆
				standardDeck.forEach(card => {
					// 只添加牌堆中存在的卡牌类型
					if (deck.some(c => c.name === card.name)) {
						typeSet.add(card.name);
					}
				});

				// 转换为数组并排序（中文排序）
				return Array.from(typeSet).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN'));
			}

			// 添加特定卡牌到手牌
			function addSpecificCard(cardName) {
				// 在牌堆中查找该类型卡牌
				const availableCards = deck.filter(c => c.name === cardName);

				// 检查是否存在
				if (availableCards.length === 0) {
					alert(`牌堆中没有【${cardName}】！`);
					log(`尝试添加${cardName}失败（牌堆无此卡）`);
					return;
				}

				// 使用加密随机数选择一张牌
				const randomBuffer = new Uint32Array(1);
				window.crypto.getRandomValues(randomBuffer);
				const selectedIndex = randomBuffer[0] % availableCards.length;
				const selectedCard = availableCards[selectedIndex];

				// 在牌堆中查找该牌的位置
				const deckIndex = deck.findIndex(c => c.uid === selectedCard.uid);

				// 如果找到则移动该牌
				if (deckIndex > -1) {
					// 从牌堆移除
					const [removed] = deck.splice(deckIndex, 1);

					// 添加到手牌
					hand.push(removed);

					// 记录日志
					log(`手动添加卡牌：${removed.name} ${removed.suit}${getPointDisplay(removed.point)}`);

					// 更新界面
					updateUI();
					updateRemaining();

					// 重新生成MD5（牌堆已改变）
					generateDeckMD5();

					// 显示操作成功反馈
					const feedback = document.createElement('div');
					feedback.textContent = `已添加：${removed.name}`;
					feedback.style = `
						position:fixed; 
						top:20px; 
						left:50%; 
						transform:translateX(-50%); 
						padding:10px; 
						background:#4CAF50; 
						color:white;
						z-index:10000;
					`;
					document.body.appendChild(feedback);

					// 2秒后移除反馈
					setTimeout(() => feedback.remove(), 2000);
				}
			}

			// 更新提示框位置（防止超出屏幕）
			function updateTooltipAlignment() {
				// 获取所有提示容器
				const tooltipContainers = document.querySelectorAll('.tooltip-container');

				// 遍历每个容器
				tooltipContainers.forEach(container => {
					const button = container.querySelector('button');
					const tooltip = container.querySelector('.tooltip');

					// 确保元素存在
					if (button && tooltip) {
						// 获取按钮位置信息
						const rect = button.getBoundingClientRect();
						const viewportWidth = window.innerWidth;
						const tooltipWidth = tooltip.offsetWidth || 350; // 默认宽度

						// 计算左右可用空间
						const leftSpace = rect.left;
						const rightSpace = viewportWidth - rect.right;

						// 根据空间决定提示框位置
						if (rightSpace >= tooltipWidth) {
							// 右侧空间足够
							container.classList.remove('right-align');
						} else if (leftSpace >= tooltipWidth) {
							// 左侧空间足够
							container.classList.add('right-align');
						} else {
							// 空间不足时选择空间较大的一侧
							if (rightSpace > leftSpace) {
								container.classList.remove('right-align');
							} else {
								container.classList.add('right-align');
							}
						}
					}
				});
			}

			// 添加事件监听器确保提示框位置正确
			window.addEventListener('load', () => {
				// 延迟100ms确保页面完全加载
				setTimeout(updateTooltipAlignment, 100);
			});
			window.addEventListener('resize', updateTooltipAlignment); // 窗口大小变化时更新
			window.addEventListener('scroll', updateTooltipAlignment); // 滚动时更新
			document.querySelectorAll('.tooltip-container').forEach(container => {
				// 鼠标悬停时更新
				container.addEventListener('mouseenter', updateTooltipAlignment);
			});

			// 初始化游戏
			function initializeGame() {
				// 初始化牌堆
				initializeDeck();

				// 初始化按钮状态
				initializeButtons();

				// 绑定键盘事件
				document.addEventListener('keydown', handleKeyPress);

				// 根据开发模式显示/隐藏测试按钮
				const isDevMode = true; // 在实际应用中应从配置获取
				document.getElementById('testUniformBtn').style.display = isDevMode ? 'inline' : 'none';
			}

			// 绑定抽牌按钮事件
			document.getElementById('draw1Button').addEventListener('click', () => drawCards(1));
			document.getElementById('draw2Button').addEventListener('click', () => drawCards(2));
			document.getElementById('draw3Button').addEventListener('click', () => drawCards(3));
			document.getElementById('draw4Button').addEventListener('click', () => drawCards(4));

			// 绑定牌堆操作按钮事件
			document.getElementById('revealButton').addEventListener('click', revealDeck);
			document.getElementById('highlightButton').addEventListener('click', highlightZhugeLianNu);

			// 洗牌按钮
			document.getElementById('shuffleButton').addEventListener('click', () => {
				initializeDeck(); // 重新初始化牌堆
				log("用户点击了重新洗牌按钮");
			});

			// 脚气卡按钮
			document.getElementById('reshuffleBtn').addEventListener('click', handleReshuffle);

			// 游戏阶段按钮
			document.getElementById('drawBtn').addEventListener('click', drawPhase);
			document.getElementById('playBtn').addEventListener('click', playPhase);
			document.getElementById('endPlayBtn').addEventListener('click', endPlayPhase);

			// 强制刷新按钮
			document.getElementById('reloadButton').addEventListener('click', () => {
				if (confirm("确定要强制刷新页面吗？网页将回到初始页面")) {
					location.reload(true);
				}
			});

			// 洗牌均匀性测试按钮
			document.getElementById('testUniformBtn').addEventListener('click', async () => {
				// 显示性能警告
				const userConfirm = await showPerformanceWarning();
				if (userConfirm) {
					console.log('开始执行均匀性测试');
					testShuffleUniformity();
				}
			});

			// 启动游戏
			initializeGame();

			// 获取按钮
			const backToTopBtn = document.getElementById('backToTopBtn');

			// 滚动事件监听，控制按钮显示隐藏
			window.addEventListener('scroll', () => {
				if (window.scrollY > 200) { // 当滚动距离大于200时显示按钮
					backToTopBtn.style.display = 'block';
				} else {
					backToTopBtn.style.display = 'none';
				}
			});

			// 点击按钮回到顶部
			backToTopBtn.addEventListener('click', () => {
				window.scrollTo({
					top: 0,
					behavior: 'smooth' // 平滑滚动
				});
			});
		</script>
		<footer class="site-footer">
			<div class="author-info">
				<p>
					作者： <a href="https://space.bilibili.com/87412647?spm_id_from=333.1007.0.0"
						target="_blank">bilibili月が綺麗ですね_</a><br />
					联系方式：<a href="mailto:3099637681@qq.com" target="_blank">3099637681@qq.com（QQ同号）</a><br />
					有什么新功能或建议欢迎骚扰（著名来意）<br />
					<a href="https://1145141919810tonny.github.io/sgsmoniqi/" target="_blank">点击此处使用GitHub Pages在线服务</a>
				</p>
			</div>
			<div class="code-update">
				<a href="https://www.bilibili.com/read/readlist/rl929858?spm_id_from=333.1387.0.0" target="_blank"
					class="bili-btn" rel="noopener noreferrer">
					[bilibili]获取更新动态
				</a>
				<a href="https://github.com/1145141919810TONNY/sgsmoniqi/" target="_blank" class="github-btn"
					rel="noopener noreferrer">
					[GitHub]获取后续代码更新
				</a>
				<a href="https://gitcode.com/TONNY114514/sgsmnq?source_module=search_project" target="_blank"
					class="gitcode-btn" rel="noopener noreferrer">
					[GitCode]获取后续代码更新(国内git)
				</a>
			</div>
			<div class="license-notice">
				<p>
					Copyright &copy; <span id="copyright-year">2025</span> bilibili 月が綺麗ですね_<br />
					Released under the
					<a href="MIT LICENSE.html" title="查看MIT许可证" class="license-link" target="_blank">
						MIT License
					</a>
				</p>
				<p class="i18n-annotation">
					(法律条款以英文版<a href="MIT LICENSE.html" target="_blank">LICENSE</a>文件为准)
				</p>
			</div>
		</footer>
	</body>
</html>
